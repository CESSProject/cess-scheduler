// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/..
#cgo pkg-config: ${SRCDIR}/../cesscrypto.pc
#include "../cesscrypto.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocCessBLSSignatureMemory allocates memory for type C.cess_BLSSignature in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessBLSSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessBLSSignatureValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessBLSSignatureValue = unsafe.Sizeof([1]C.cess_BLSSignature{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessBLSSignature) Ref() *C.cess_BLSSignature {
	if x == nil {
		return nil
	}
	return x.ref9d0461e9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessBLSSignature) Free() {
	if x != nil && x.allocs9d0461e9 != nil {
		x.allocs9d0461e9.(*cgoAllocMap).Free()
		x.ref9d0461e9 = nil
	}
}

// NewCessBLSSignatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessBLSSignatureRef(ref unsafe.Pointer) *CessBLSSignature {
	if ref == nil {
		return nil
	}
	obj := new(CessBLSSignature)
	obj.ref9d0461e9 = (*C.cess_BLSSignature)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessBLSSignature) PassRef() (*C.cess_BLSSignature, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9d0461e9 != nil {
		return x.ref9d0461e9, nil
	}
	mem9d0461e9 := allocCessBLSSignatureMemory(1)
	ref9d0461e9 := (*C.cess_BLSSignature)(mem9d0461e9)
	allocs9d0461e9 := new(cgoAllocMap)
	allocs9d0461e9.Add(mem9d0461e9)

	var cinner_allocs *cgoAllocMap
	ref9d0461e9.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs9d0461e9.Borrow(cinner_allocs)

	x.ref9d0461e9 = ref9d0461e9
	x.allocs9d0461e9 = allocs9d0461e9
	return ref9d0461e9, allocs9d0461e9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessBLSSignature) PassValue() (C.cess_BLSSignature, *cgoAllocMap) {
	if x.ref9d0461e9 != nil {
		return *x.ref9d0461e9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessBLSSignature) Deref() {
	if x.ref9d0461e9 == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.ref9d0461e9.inner))
}

// allocCessAggregateResponseMemory allocates memory for type C.cess_AggregateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessAggregateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessAggregateResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessAggregateResponseValue = unsafe.Sizeof([1]C.cess_AggregateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessAggregateResponse) Ref() *C.cess_AggregateResponse {
	if x == nil {
		return nil
	}
	return x.refbd7bef7e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessAggregateResponse) Free() {
	if x != nil && x.allocsbd7bef7e != nil {
		x.allocsbd7bef7e.(*cgoAllocMap).Free()
		x.refbd7bef7e = nil
	}
}

// NewCessAggregateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessAggregateResponseRef(ref unsafe.Pointer) *CessAggregateResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessAggregateResponse)
	obj.refbd7bef7e = (*C.cess_AggregateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessAggregateResponse) PassRef() (*C.cess_AggregateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd7bef7e != nil {
		return x.refbd7bef7e, nil
	}
	membd7bef7e := allocCessAggregateResponseMemory(1)
	refbd7bef7e := (*C.cess_AggregateResponse)(membd7bef7e)
	allocsbd7bef7e := new(cgoAllocMap)
	allocsbd7bef7e.Add(membd7bef7e)

	var csignature_allocs *cgoAllocMap
	refbd7bef7e.signature, csignature_allocs = x.Signature.PassValue()
	allocsbd7bef7e.Borrow(csignature_allocs)

	x.refbd7bef7e = refbd7bef7e
	x.allocsbd7bef7e = allocsbd7bef7e
	return refbd7bef7e, allocsbd7bef7e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessAggregateResponse) PassValue() (C.cess_AggregateResponse, *cgoAllocMap) {
	if x.refbd7bef7e != nil {
		return *x.refbd7bef7e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessAggregateResponse) Deref() {
	if x.refbd7bef7e == nil {
		return
	}
	x.Signature = *NewCessBLSSignatureRef(unsafe.Pointer(&x.refbd7bef7e.signature))
}

// allocCessAggregateProofMemory allocates memory for type C.cess_AggregateProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessAggregateProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessAggregateProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessAggregateProofValue = unsafe.Sizeof([1]C.cess_AggregateProof{})

// unpackPCharString copies the data from Go string as *C.char.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	str = safeString(str)
	mem0 := unsafe.Pointer(C.CString(str))
	allocs.Add(mem0)
	return (*C.char)(mem0), allocs
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// copyPUint8TBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8TBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8TValue) * slice.Len,
		Cap:  int(sizeOfUint8TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocUint8TMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint8TValue = unsafe.Sizeof([1]C.uint8_t{})

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessAggregateProof) Ref() *C.cess_AggregateProof {
	if x == nil {
		return nil
	}
	return x.reff0491ca3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessAggregateProof) Free() {
	if x != nil && x.allocsf0491ca3 != nil {
		x.allocsf0491ca3.(*cgoAllocMap).Free()
		x.reff0491ca3 = nil
	}
}

// NewCessAggregateProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessAggregateProofRef(ref unsafe.Pointer) *CessAggregateProof {
	if ref == nil {
		return nil
	}
	obj := new(CessAggregateProof)
	obj.reff0491ca3 = (*C.cess_AggregateProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessAggregateProof) PassRef() (*C.cess_AggregateProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff0491ca3 != nil {
		return x.reff0491ca3, nil
	}
	memf0491ca3 := allocCessAggregateProofMemory(1)
	reff0491ca3 := (*C.cess_AggregateProof)(memf0491ca3)
	allocsf0491ca3 := new(cgoAllocMap)
	allocsf0491ca3.Add(memf0491ca3)

	var cstatus_code_allocs *cgoAllocMap
	reff0491ca3.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsf0491ca3.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	reff0491ca3.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsf0491ca3.Borrow(cerror_msg_allocs)

	var cproof_len_allocs *cgoAllocMap
	reff0491ca3.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocsf0491ca3.Borrow(cproof_len_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	reff0491ca3.proof_ptr, cproof_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.ProofPtr)))
	allocsf0491ca3.Borrow(cproof_ptr_allocs)

	x.reff0491ca3 = reff0491ca3
	x.allocsf0491ca3 = allocsf0491ca3
	return reff0491ca3, allocsf0491ca3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessAggregateProof) PassValue() (C.cess_AggregateProof, *cgoAllocMap) {
	if x.reff0491ca3 != nil {
		return *x.reff0491ca3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessAggregateProof) Deref() {
	if x.reff0491ca3 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.reff0491ca3.status_code)
	x.ErrorMsg = packPCharString(x.reff0491ca3.error_msg)
	x.ProofLen = (uint)(x.reff0491ca3.proof_len)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.ProofPtr))
	hxfc4425b.Data = unsafe.Pointer(x.reff0491ca3.proof_ptr)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocCess32ByteArrayMemory allocates memory for type C.cess_32ByteArray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCess32ByteArrayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCess32ByteArrayValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCess32ByteArrayValue = unsafe.Sizeof([1]C.cess_32ByteArray{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Cess32ByteArray) Ref() *C.cess_32ByteArray {
	if x == nil {
		return nil
	}
	return x.ref2a5048bc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Cess32ByteArray) Free() {
	if x != nil && x.allocs2a5048bc != nil {
		x.allocs2a5048bc.(*cgoAllocMap).Free()
		x.ref2a5048bc = nil
	}
}

// NewCess32ByteArrayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCess32ByteArrayRef(ref unsafe.Pointer) *Cess32ByteArray {
	if ref == nil {
		return nil
	}
	obj := new(Cess32ByteArray)
	obj.ref2a5048bc = (*C.cess_32ByteArray)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Cess32ByteArray) PassRef() (*C.cess_32ByteArray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2a5048bc != nil {
		return x.ref2a5048bc, nil
	}
	mem2a5048bc := allocCess32ByteArrayMemory(1)
	ref2a5048bc := (*C.cess_32ByteArray)(mem2a5048bc)
	allocs2a5048bc := new(cgoAllocMap)
	allocs2a5048bc.Add(mem2a5048bc)

	var cinner_allocs *cgoAllocMap
	ref2a5048bc.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs2a5048bc.Borrow(cinner_allocs)

	x.ref2a5048bc = ref2a5048bc
	x.allocs2a5048bc = allocs2a5048bc
	return ref2a5048bc, allocs2a5048bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Cess32ByteArray) PassValue() (C.cess_32ByteArray, *cgoAllocMap) {
	if x.ref2a5048bc != nil {
		return *x.ref2a5048bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Cess32ByteArray) Deref() {
	if x.ref2a5048bc == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref2a5048bc.inner))
}

// allocCessAggregationInputsMemory allocates memory for type C.cess_AggregationInputs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessAggregationInputsMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessAggregationInputsValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessAggregationInputsValue = unsafe.Sizeof([1]C.cess_AggregationInputs{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessAggregationInputs) Ref() *C.cess_AggregationInputs {
	if x == nil {
		return nil
	}
	return x.ref9e2d2bda
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessAggregationInputs) Free() {
	if x != nil && x.allocs9e2d2bda != nil {
		x.allocs9e2d2bda.(*cgoAllocMap).Free()
		x.ref9e2d2bda = nil
	}
}

// NewCessAggregationInputsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessAggregationInputsRef(ref unsafe.Pointer) *CessAggregationInputs {
	if ref == nil {
		return nil
	}
	obj := new(CessAggregationInputs)
	obj.ref9e2d2bda = (*C.cess_AggregationInputs)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessAggregationInputs) PassRef() (*C.cess_AggregationInputs, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9e2d2bda != nil {
		return x.ref9e2d2bda, nil
	}
	mem9e2d2bda := allocCessAggregationInputsMemory(1)
	ref9e2d2bda := (*C.cess_AggregationInputs)(mem9e2d2bda)
	allocs9e2d2bda := new(cgoAllocMap)
	allocs9e2d2bda.Add(mem9e2d2bda)

	var ccomm_r_allocs *cgoAllocMap
	ref9e2d2bda.comm_r, ccomm_r_allocs = x.CommR.PassValue()
	allocs9e2d2bda.Borrow(ccomm_r_allocs)

	var ccomm_d_allocs *cgoAllocMap
	ref9e2d2bda.comm_d, ccomm_d_allocs = x.CommD.PassValue()
	allocs9e2d2bda.Borrow(ccomm_d_allocs)

	var csector_id_allocs *cgoAllocMap
	ref9e2d2bda.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs9e2d2bda.Borrow(csector_id_allocs)

	var cticket_allocs *cgoAllocMap
	ref9e2d2bda.ticket, cticket_allocs = x.Ticket.PassValue()
	allocs9e2d2bda.Borrow(cticket_allocs)

	var cseed_allocs *cgoAllocMap
	ref9e2d2bda.seed, cseed_allocs = x.Seed.PassValue()
	allocs9e2d2bda.Borrow(cseed_allocs)

	x.ref9e2d2bda = ref9e2d2bda
	x.allocs9e2d2bda = allocs9e2d2bda
	return ref9e2d2bda, allocs9e2d2bda

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessAggregationInputs) PassValue() (C.cess_AggregationInputs, *cgoAllocMap) {
	if x.ref9e2d2bda != nil {
		return *x.ref9e2d2bda, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessAggregationInputs) Deref() {
	if x.ref9e2d2bda == nil {
		return
	}
	x.CommR = *NewCess32ByteArrayRef(unsafe.Pointer(&x.ref9e2d2bda.comm_r))
	x.CommD = *NewCess32ByteArrayRef(unsafe.Pointer(&x.ref9e2d2bda.comm_d))
	x.SectorId = (uint64)(x.ref9e2d2bda.sector_id)
	x.Ticket = *NewCess32ByteArrayRef(unsafe.Pointer(&x.ref9e2d2bda.ticket))
	x.Seed = *NewCess32ByteArrayRef(unsafe.Pointer(&x.ref9e2d2bda.seed))
}

// allocCessSealCommitPhase2ResponseMemory allocates memory for type C.cess_SealCommitPhase2Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessSealCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessSealCommitPhase2ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessSealCommitPhase2ResponseValue = unsafe.Sizeof([1]C.cess_SealCommitPhase2Response{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSCessAggregationInputs transforms a sliced Go data structure into plain C format.
func unpackSCessAggregationInputs(x []CessAggregationInputs) (unpacked *C.cess_AggregationInputs, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessAggregationInputsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_AggregationInputs)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_AggregationInputs)(h.Data)
	return
}

// packSCessAggregationInputs reads sliced Go data structure out from plain C format.
func packSCessAggregationInputs(v []CessAggregationInputs, ptr0 *C.cess_AggregationInputs) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessAggregationInputsValue]C.cess_AggregationInputs)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessAggregationInputsRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessSealCommitPhase2Response) Ref() *C.cess_SealCommitPhase2Response {
	if x == nil {
		return nil
	}
	return x.refb2950303
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessSealCommitPhase2Response) Free() {
	if x != nil && x.allocsb2950303 != nil {
		x.allocsb2950303.(*cgoAllocMap).Free()
		x.refb2950303 = nil
	}
}

// NewCessSealCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessSealCommitPhase2ResponseRef(ref unsafe.Pointer) *CessSealCommitPhase2Response {
	if ref == nil {
		return nil
	}
	obj := new(CessSealCommitPhase2Response)
	obj.refb2950303 = (*C.cess_SealCommitPhase2Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessSealCommitPhase2Response) PassRef() (*C.cess_SealCommitPhase2Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb2950303 != nil {
		return x.refb2950303, nil
	}
	memb2950303 := allocCessSealCommitPhase2ResponseMemory(1)
	refb2950303 := (*C.cess_SealCommitPhase2Response)(memb2950303)
	allocsb2950303 := new(cgoAllocMap)
	allocsb2950303.Add(memb2950303)

	var cstatus_code_allocs *cgoAllocMap
	refb2950303.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsb2950303.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb2950303.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsb2950303.Borrow(cerror_msg_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	refb2950303.proof_ptr, cproof_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.ProofPtr)))
	allocsb2950303.Borrow(cproof_ptr_allocs)

	var cproof_len_allocs *cgoAllocMap
	refb2950303.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocsb2950303.Borrow(cproof_len_allocs)

	var ccommit_inputs_ptr_allocs *cgoAllocMap
	refb2950303.commit_inputs_ptr, ccommit_inputs_ptr_allocs = unpackSCessAggregationInputs(x.CommitInputsPtr)
	allocsb2950303.Borrow(ccommit_inputs_ptr_allocs)

	var ccommit_inputs_len_allocs *cgoAllocMap
	refb2950303.commit_inputs_len, ccommit_inputs_len_allocs = (C.size_t)(x.CommitInputsLen), cgoAllocsUnknown
	allocsb2950303.Borrow(ccommit_inputs_len_allocs)

	x.refb2950303 = refb2950303
	x.allocsb2950303 = allocsb2950303
	return refb2950303, allocsb2950303

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessSealCommitPhase2Response) PassValue() (C.cess_SealCommitPhase2Response, *cgoAllocMap) {
	if x.refb2950303 != nil {
		return *x.refb2950303, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessSealCommitPhase2Response) Deref() {
	if x.refb2950303 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refb2950303.status_code)
	x.ErrorMsg = packPCharString(x.refb2950303.error_msg)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.ProofPtr))
	hxf95e7c8.Data = unsafe.Pointer(x.refb2950303.proof_ptr)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.ProofLen = (uint)(x.refb2950303.proof_len)
	packSCessAggregationInputs(x.CommitInputsPtr, x.refb2950303.commit_inputs_ptr)
	x.CommitInputsLen = (uint)(x.refb2950303.commit_inputs_len)
}

// allocCessClearCacheResponseMemory allocates memory for type C.cess_ClearCacheResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessClearCacheResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessClearCacheResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessClearCacheResponseValue = unsafe.Sizeof([1]C.cess_ClearCacheResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessClearCacheResponse) Ref() *C.cess_ClearCacheResponse {
	if x == nil {
		return nil
	}
	return x.ref2d18d192
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessClearCacheResponse) Free() {
	if x != nil && x.allocs2d18d192 != nil {
		x.allocs2d18d192.(*cgoAllocMap).Free()
		x.ref2d18d192 = nil
	}
}

// NewCessClearCacheResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessClearCacheResponseRef(ref unsafe.Pointer) *CessClearCacheResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessClearCacheResponse)
	obj.ref2d18d192 = (*C.cess_ClearCacheResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessClearCacheResponse) PassRef() (*C.cess_ClearCacheResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2d18d192 != nil {
		return x.ref2d18d192, nil
	}
	mem2d18d192 := allocCessClearCacheResponseMemory(1)
	ref2d18d192 := (*C.cess_ClearCacheResponse)(mem2d18d192)
	allocs2d18d192 := new(cgoAllocMap)
	allocs2d18d192.Add(mem2d18d192)

	var cerror_msg_allocs *cgoAllocMap
	ref2d18d192.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs2d18d192.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref2d18d192.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs2d18d192.Borrow(cstatus_code_allocs)

	x.ref2d18d192 = ref2d18d192
	x.allocs2d18d192 = allocs2d18d192
	return ref2d18d192, allocs2d18d192

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessClearCacheResponse) PassValue() (C.cess_ClearCacheResponse, *cgoAllocMap) {
	if x.ref2d18d192 != nil {
		return *x.ref2d18d192, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessClearCacheResponse) Deref() {
	if x.ref2d18d192 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref2d18d192.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref2d18d192.status_code)
}

// allocCessZeroSignatureResponseMemory allocates memory for type C.cess_ZeroSignatureResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessZeroSignatureResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessZeroSignatureResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessZeroSignatureResponseValue = unsafe.Sizeof([1]C.cess_ZeroSignatureResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessZeroSignatureResponse) Ref() *C.cess_ZeroSignatureResponse {
	if x == nil {
		return nil
	}
	return x.ref4ae3eac9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessZeroSignatureResponse) Free() {
	if x != nil && x.allocs4ae3eac9 != nil {
		x.allocs4ae3eac9.(*cgoAllocMap).Free()
		x.ref4ae3eac9 = nil
	}
}

// NewCessZeroSignatureResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessZeroSignatureResponseRef(ref unsafe.Pointer) *CessZeroSignatureResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessZeroSignatureResponse)
	obj.ref4ae3eac9 = (*C.cess_ZeroSignatureResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessZeroSignatureResponse) PassRef() (*C.cess_ZeroSignatureResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ae3eac9 != nil {
		return x.ref4ae3eac9, nil
	}
	mem4ae3eac9 := allocCessZeroSignatureResponseMemory(1)
	ref4ae3eac9 := (*C.cess_ZeroSignatureResponse)(mem4ae3eac9)
	allocs4ae3eac9 := new(cgoAllocMap)
	allocs4ae3eac9.Add(mem4ae3eac9)

	var csignature_allocs *cgoAllocMap
	ref4ae3eac9.signature, csignature_allocs = x.Signature.PassValue()
	allocs4ae3eac9.Borrow(csignature_allocs)

	x.ref4ae3eac9 = ref4ae3eac9
	x.allocs4ae3eac9 = allocs4ae3eac9
	return ref4ae3eac9, allocs4ae3eac9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessZeroSignatureResponse) PassValue() (C.cess_ZeroSignatureResponse, *cgoAllocMap) {
	if x.ref4ae3eac9 != nil {
		return *x.ref4ae3eac9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessZeroSignatureResponse) Deref() {
	if x.ref4ae3eac9 == nil {
		return
	}
	x.Signature = *NewCessBLSSignatureRef(unsafe.Pointer(&x.ref4ae3eac9.signature))
}

// allocCessFauxRepResponseMemory allocates memory for type C.cess_FauxRepResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessFauxRepResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessFauxRepResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessFauxRepResponseValue = unsafe.Sizeof([1]C.cess_FauxRepResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessFauxRepResponse) Ref() *C.cess_FauxRepResponse {
	if x == nil {
		return nil
	}
	return x.refb1d365d2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessFauxRepResponse) Free() {
	if x != nil && x.allocsb1d365d2 != nil {
		x.allocsb1d365d2.(*cgoAllocMap).Free()
		x.refb1d365d2 = nil
	}
}

// NewCessFauxRepResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessFauxRepResponseRef(ref unsafe.Pointer) *CessFauxRepResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessFauxRepResponse)
	obj.refb1d365d2 = (*C.cess_FauxRepResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessFauxRepResponse) PassRef() (*C.cess_FauxRepResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb1d365d2 != nil {
		return x.refb1d365d2, nil
	}
	memb1d365d2 := allocCessFauxRepResponseMemory(1)
	refb1d365d2 := (*C.cess_FauxRepResponse)(memb1d365d2)
	allocsb1d365d2 := new(cgoAllocMap)
	allocsb1d365d2.Add(memb1d365d2)

	var cerror_msg_allocs *cgoAllocMap
	refb1d365d2.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsb1d365d2.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refb1d365d2.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsb1d365d2.Borrow(cstatus_code_allocs)

	var ccommitment_allocs *cgoAllocMap
	refb1d365d2.commitment, ccommitment_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Commitment)), cgoAllocsUnknown
	allocsb1d365d2.Borrow(ccommitment_allocs)

	x.refb1d365d2 = refb1d365d2
	x.allocsb1d365d2 = allocsb1d365d2
	return refb1d365d2, allocsb1d365d2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessFauxRepResponse) PassValue() (C.cess_FauxRepResponse, *cgoAllocMap) {
	if x.refb1d365d2 != nil {
		return *x.refb1d365d2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessFauxRepResponse) Deref() {
	if x.refb1d365d2 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.refb1d365d2.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.refb1d365d2.status_code)
	x.Commitment = *(*[32]byte)(unsafe.Pointer(&x.refb1d365d2.commitment))
}

// allocCessFinalizeTicketResponseMemory allocates memory for type C.cess_FinalizeTicketResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessFinalizeTicketResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessFinalizeTicketResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessFinalizeTicketResponseValue = unsafe.Sizeof([1]C.cess_FinalizeTicketResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessFinalizeTicketResponse) Ref() *C.cess_FinalizeTicketResponse {
	if x == nil {
		return nil
	}
	return x.ref216bcdf3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessFinalizeTicketResponse) Free() {
	if x != nil && x.allocs216bcdf3 != nil {
		x.allocs216bcdf3.(*cgoAllocMap).Free()
		x.ref216bcdf3 = nil
	}
}

// NewCessFinalizeTicketResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessFinalizeTicketResponseRef(ref unsafe.Pointer) *CessFinalizeTicketResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessFinalizeTicketResponse)
	obj.ref216bcdf3 = (*C.cess_FinalizeTicketResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessFinalizeTicketResponse) PassRef() (*C.cess_FinalizeTicketResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref216bcdf3 != nil {
		return x.ref216bcdf3, nil
	}
	mem216bcdf3 := allocCessFinalizeTicketResponseMemory(1)
	ref216bcdf3 := (*C.cess_FinalizeTicketResponse)(mem216bcdf3)
	allocs216bcdf3 := new(cgoAllocMap)
	allocs216bcdf3.Add(mem216bcdf3)

	var cstatus_code_allocs *cgoAllocMap
	ref216bcdf3.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs216bcdf3.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref216bcdf3.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs216bcdf3.Borrow(cerror_msg_allocs)

	var cticket_allocs *cgoAllocMap
	ref216bcdf3.ticket, cticket_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Ticket)), cgoAllocsUnknown
	allocs216bcdf3.Borrow(cticket_allocs)

	x.ref216bcdf3 = ref216bcdf3
	x.allocs216bcdf3 = allocs216bcdf3
	return ref216bcdf3, allocs216bcdf3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessFinalizeTicketResponse) PassValue() (C.cess_FinalizeTicketResponse, *cgoAllocMap) {
	if x.ref216bcdf3 != nil {
		return *x.ref216bcdf3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessFinalizeTicketResponse) Deref() {
	if x.ref216bcdf3 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref216bcdf3.status_code)
	x.ErrorMsg = packPCharString(x.ref216bcdf3.error_msg)
	x.Ticket = *(*[32]byte)(unsafe.Pointer(&x.ref216bcdf3.ticket))
}

// allocCessGenerateDataCommitmentResponseMemory allocates memory for type C.cess_GenerateDataCommitmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateDataCommitmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateDataCommitmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateDataCommitmentResponseValue = unsafe.Sizeof([1]C.cess_GenerateDataCommitmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateDataCommitmentResponse) Ref() *C.cess_GenerateDataCommitmentResponse {
	if x == nil {
		return nil
	}
	return x.refcc79ffd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateDataCommitmentResponse) Free() {
	if x != nil && x.allocscc79ffd9 != nil {
		x.allocscc79ffd9.(*cgoAllocMap).Free()
		x.refcc79ffd9 = nil
	}
}

// NewCessGenerateDataCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateDataCommitmentResponseRef(ref unsafe.Pointer) *CessGenerateDataCommitmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateDataCommitmentResponse)
	obj.refcc79ffd9 = (*C.cess_GenerateDataCommitmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateDataCommitmentResponse) PassRef() (*C.cess_GenerateDataCommitmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcc79ffd9 != nil {
		return x.refcc79ffd9, nil
	}
	memcc79ffd9 := allocCessGenerateDataCommitmentResponseMemory(1)
	refcc79ffd9 := (*C.cess_GenerateDataCommitmentResponse)(memcc79ffd9)
	allocscc79ffd9 := new(cgoAllocMap)
	allocscc79ffd9.Add(memcc79ffd9)

	var cstatus_code_allocs *cgoAllocMap
	refcc79ffd9.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocscc79ffd9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refcc79ffd9.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocscc79ffd9.Borrow(cerror_msg_allocs)

	var ccomm_d_allocs *cgoAllocMap
	refcc79ffd9.comm_d, ccomm_d_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommD)), cgoAllocsUnknown
	allocscc79ffd9.Borrow(ccomm_d_allocs)

	x.refcc79ffd9 = refcc79ffd9
	x.allocscc79ffd9 = allocscc79ffd9
	return refcc79ffd9, allocscc79ffd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateDataCommitmentResponse) PassValue() (C.cess_GenerateDataCommitmentResponse, *cgoAllocMap) {
	if x.refcc79ffd9 != nil {
		return *x.refcc79ffd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateDataCommitmentResponse) Deref() {
	if x.refcc79ffd9 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refcc79ffd9.status_code)
	x.ErrorMsg = packPCharString(x.refcc79ffd9.error_msg)
	x.CommD = *(*[32]byte)(unsafe.Pointer(&x.refcc79ffd9.comm_d))
}

// allocCessGenerateFallbackSectorChallengesResponseMemory allocates memory for type C.cess_GenerateFallbackSectorChallengesResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateFallbackSectorChallengesResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateFallbackSectorChallengesResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateFallbackSectorChallengesResponseValue = unsafe.Sizeof([1]C.cess_GenerateFallbackSectorChallengesResponse{})

// copyPUint64TBytes copies the data from Go slice as *C.uint64_t.
func copyPUint64TBytes(slice *sliceHeader) (*C.uint64_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint64TValue) * slice.Len,
		Cap:  int(sizeOfUint64TValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint64_t)(mem0), allocs
}

// allocUint64TMemory allocates memory for type C.uint64_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint64TMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint64TValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfUint64TValue = unsafe.Sizeof([1]C.uint64_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateFallbackSectorChallengesResponse) Ref() *C.cess_GenerateFallbackSectorChallengesResponse {
	if x == nil {
		return nil
	}
	return x.ref5a2a4adf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateFallbackSectorChallengesResponse) Free() {
	if x != nil && x.allocs5a2a4adf != nil {
		x.allocs5a2a4adf.(*cgoAllocMap).Free()
		x.ref5a2a4adf = nil
	}
}

// NewCessGenerateFallbackSectorChallengesResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateFallbackSectorChallengesResponseRef(ref unsafe.Pointer) *CessGenerateFallbackSectorChallengesResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateFallbackSectorChallengesResponse)
	obj.ref5a2a4adf = (*C.cess_GenerateFallbackSectorChallengesResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateFallbackSectorChallengesResponse) PassRef() (*C.cess_GenerateFallbackSectorChallengesResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5a2a4adf != nil {
		return x.ref5a2a4adf, nil
	}
	mem5a2a4adf := allocCessGenerateFallbackSectorChallengesResponseMemory(1)
	ref5a2a4adf := (*C.cess_GenerateFallbackSectorChallengesResponse)(mem5a2a4adf)
	allocs5a2a4adf := new(cgoAllocMap)
	allocs5a2a4adf.Add(mem5a2a4adf)

	var cerror_msg_allocs *cgoAllocMap
	ref5a2a4adf.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs5a2a4adf.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref5a2a4adf.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5a2a4adf.Borrow(cstatus_code_allocs)

	var cids_ptr_allocs *cgoAllocMap
	ref5a2a4adf.ids_ptr, cids_ptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.IdsPtr)))
	allocs5a2a4adf.Borrow(cids_ptr_allocs)

	var cids_len_allocs *cgoAllocMap
	ref5a2a4adf.ids_len, cids_len_allocs = (C.size_t)(x.IdsLen), cgoAllocsUnknown
	allocs5a2a4adf.Borrow(cids_len_allocs)

	var cchallenges_ptr_allocs *cgoAllocMap
	ref5a2a4adf.challenges_ptr, cchallenges_ptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.ChallengesPtr)))
	allocs5a2a4adf.Borrow(cchallenges_ptr_allocs)

	var cchallenges_len_allocs *cgoAllocMap
	ref5a2a4adf.challenges_len, cchallenges_len_allocs = (C.size_t)(x.ChallengesLen), cgoAllocsUnknown
	allocs5a2a4adf.Borrow(cchallenges_len_allocs)

	var cchallenges_stride_allocs *cgoAllocMap
	ref5a2a4adf.challenges_stride, cchallenges_stride_allocs = (C.size_t)(x.ChallengesStride), cgoAllocsUnknown
	allocs5a2a4adf.Borrow(cchallenges_stride_allocs)

	x.ref5a2a4adf = ref5a2a4adf
	x.allocs5a2a4adf = allocs5a2a4adf
	return ref5a2a4adf, allocs5a2a4adf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateFallbackSectorChallengesResponse) PassValue() (C.cess_GenerateFallbackSectorChallengesResponse, *cgoAllocMap) {
	if x.ref5a2a4adf != nil {
		return *x.ref5a2a4adf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateFallbackSectorChallengesResponse) Deref() {
	if x.ref5a2a4adf == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref5a2a4adf.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref5a2a4adf.status_code)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.IdsPtr))
	hxff2234b.Data = unsafe.Pointer(x.ref5a2a4adf.ids_ptr)
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.IdsLen = (uint)(x.ref5a2a4adf.ids_len)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.ChallengesPtr))
	hxff73280.Data = unsafe.Pointer(x.ref5a2a4adf.challenges_ptr)
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.ChallengesLen = (uint)(x.ref5a2a4adf.challenges_len)
	x.ChallengesStride = (uint)(x.ref5a2a4adf.challenges_stride)
}

// allocCessGeneratePieceCommitmentResponseMemory allocates memory for type C.cess_GeneratePieceCommitmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGeneratePieceCommitmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGeneratePieceCommitmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGeneratePieceCommitmentResponseValue = unsafe.Sizeof([1]C.cess_GeneratePieceCommitmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGeneratePieceCommitmentResponse) Ref() *C.cess_GeneratePieceCommitmentResponse {
	if x == nil {
		return nil
	}
	return x.ref4b4b5e26
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGeneratePieceCommitmentResponse) Free() {
	if x != nil && x.allocs4b4b5e26 != nil {
		x.allocs4b4b5e26.(*cgoAllocMap).Free()
		x.ref4b4b5e26 = nil
	}
}

// NewCessGeneratePieceCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGeneratePieceCommitmentResponseRef(ref unsafe.Pointer) *CessGeneratePieceCommitmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGeneratePieceCommitmentResponse)
	obj.ref4b4b5e26 = (*C.cess_GeneratePieceCommitmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGeneratePieceCommitmentResponse) PassRef() (*C.cess_GeneratePieceCommitmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b4b5e26 != nil {
		return x.ref4b4b5e26, nil
	}
	mem4b4b5e26 := allocCessGeneratePieceCommitmentResponseMemory(1)
	ref4b4b5e26 := (*C.cess_GeneratePieceCommitmentResponse)(mem4b4b5e26)
	allocs4b4b5e26 := new(cgoAllocMap)
	allocs4b4b5e26.Add(mem4b4b5e26)

	var cstatus_code_allocs *cgoAllocMap
	ref4b4b5e26.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs4b4b5e26.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4b4b5e26.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs4b4b5e26.Borrow(cerror_msg_allocs)

	var ccomm_p_allocs *cgoAllocMap
	ref4b4b5e26.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocs4b4b5e26.Borrow(ccomm_p_allocs)

	var cnum_bytes_aligned_allocs *cgoAllocMap
	ref4b4b5e26.num_bytes_aligned, cnum_bytes_aligned_allocs = (C.uint64_t)(x.NumBytesAligned), cgoAllocsUnknown
	allocs4b4b5e26.Borrow(cnum_bytes_aligned_allocs)

	x.ref4b4b5e26 = ref4b4b5e26
	x.allocs4b4b5e26 = allocs4b4b5e26
	return ref4b4b5e26, allocs4b4b5e26

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGeneratePieceCommitmentResponse) PassValue() (C.cess_GeneratePieceCommitmentResponse, *cgoAllocMap) {
	if x.ref4b4b5e26 != nil {
		return *x.ref4b4b5e26, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGeneratePieceCommitmentResponse) Deref() {
	if x.ref4b4b5e26 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref4b4b5e26.status_code)
	x.ErrorMsg = packPCharString(x.ref4b4b5e26.error_msg)
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.ref4b4b5e26.comm_p))
	x.NumBytesAligned = (uint64)(x.ref4b4b5e26.num_bytes_aligned)
}

// allocCessVanillaProofMemory allocates memory for type C.cess_VanillaProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessVanillaProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessVanillaProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessVanillaProofValue = unsafe.Sizeof([1]C.cess_VanillaProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessVanillaProof) Ref() *C.cess_VanillaProof {
	if x == nil {
		return nil
	}
	return x.ref8c4f0bdf
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessVanillaProof) Free() {
	if x != nil && x.allocs8c4f0bdf != nil {
		x.allocs8c4f0bdf.(*cgoAllocMap).Free()
		x.ref8c4f0bdf = nil
	}
}

// NewCessVanillaProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessVanillaProofRef(ref unsafe.Pointer) *CessVanillaProof {
	if ref == nil {
		return nil
	}
	obj := new(CessVanillaProof)
	obj.ref8c4f0bdf = (*C.cess_VanillaProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessVanillaProof) PassRef() (*C.cess_VanillaProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8c4f0bdf != nil {
		return x.ref8c4f0bdf, nil
	}
	mem8c4f0bdf := allocCessVanillaProofMemory(1)
	ref8c4f0bdf := (*C.cess_VanillaProof)(mem8c4f0bdf)
	allocs8c4f0bdf := new(cgoAllocMap)
	allocs8c4f0bdf.Add(mem8c4f0bdf)

	var cproof_len_allocs *cgoAllocMap
	ref8c4f0bdf.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocs8c4f0bdf.Borrow(cproof_len_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	ref8c4f0bdf.proof_ptr, cproof_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.ProofPtr)))
	allocs8c4f0bdf.Borrow(cproof_ptr_allocs)

	x.ref8c4f0bdf = ref8c4f0bdf
	x.allocs8c4f0bdf = allocs8c4f0bdf
	return ref8c4f0bdf, allocs8c4f0bdf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessVanillaProof) PassValue() (C.cess_VanillaProof, *cgoAllocMap) {
	if x.ref8c4f0bdf != nil {
		return *x.ref8c4f0bdf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessVanillaProof) Deref() {
	if x.ref8c4f0bdf == nil {
		return
	}
	x.ProofLen = (uint)(x.ref8c4f0bdf.proof_len)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.ProofPtr))
	hxfa9955c.Data = unsafe.Pointer(x.ref8c4f0bdf.proof_ptr)
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

}

// allocCessGenerateSingleVanillaProofResponseMemory allocates memory for type C.cess_GenerateSingleVanillaProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateSingleVanillaProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateSingleVanillaProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateSingleVanillaProofResponseValue = unsafe.Sizeof([1]C.cess_GenerateSingleVanillaProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateSingleVanillaProofResponse) Ref() *C.cess_GenerateSingleVanillaProofResponse {
	if x == nil {
		return nil
	}
	return x.ref7f47a3d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateSingleVanillaProofResponse) Free() {
	if x != nil && x.allocs7f47a3d8 != nil {
		x.allocs7f47a3d8.(*cgoAllocMap).Free()
		x.ref7f47a3d8 = nil
	}
}

// NewCessGenerateSingleVanillaProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateSingleVanillaProofResponseRef(ref unsafe.Pointer) *CessGenerateSingleVanillaProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateSingleVanillaProofResponse)
	obj.ref7f47a3d8 = (*C.cess_GenerateSingleVanillaProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateSingleVanillaProofResponse) PassRef() (*C.cess_GenerateSingleVanillaProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f47a3d8 != nil {
		return x.ref7f47a3d8, nil
	}
	mem7f47a3d8 := allocCessGenerateSingleVanillaProofResponseMemory(1)
	ref7f47a3d8 := (*C.cess_GenerateSingleVanillaProofResponse)(mem7f47a3d8)
	allocs7f47a3d8 := new(cgoAllocMap)
	allocs7f47a3d8.Add(mem7f47a3d8)

	var cerror_msg_allocs *cgoAllocMap
	ref7f47a3d8.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs7f47a3d8.Borrow(cerror_msg_allocs)

	var cvanilla_proof_allocs *cgoAllocMap
	ref7f47a3d8.vanilla_proof, cvanilla_proof_allocs = x.VanillaProof.PassValue()
	allocs7f47a3d8.Borrow(cvanilla_proof_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref7f47a3d8.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs7f47a3d8.Borrow(cstatus_code_allocs)

	x.ref7f47a3d8 = ref7f47a3d8
	x.allocs7f47a3d8 = allocs7f47a3d8
	return ref7f47a3d8, allocs7f47a3d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateSingleVanillaProofResponse) PassValue() (C.cess_GenerateSingleVanillaProofResponse, *cgoAllocMap) {
	if x.ref7f47a3d8 != nil {
		return *x.ref7f47a3d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateSingleVanillaProofResponse) Deref() {
	if x.ref7f47a3d8 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref7f47a3d8.error_msg)
	x.VanillaProof = *NewCessVanillaProofRef(unsafe.Pointer(&x.ref7f47a3d8.vanilla_proof))
	x.StatusCode = (FCPResponseStatus)(x.ref7f47a3d8.status_code)
}

// allocCessPartitionSnarkProofMemory allocates memory for type C.cess_PartitionSnarkProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPartitionSnarkProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPartitionSnarkProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPartitionSnarkProofValue = unsafe.Sizeof([1]C.cess_PartitionSnarkProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPartitionSnarkProof) Ref() *C.cess_PartitionSnarkProof {
	if x == nil {
		return nil
	}
	return x.ref53657584
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPartitionSnarkProof) Free() {
	if x != nil && x.allocs53657584 != nil {
		x.allocs53657584.(*cgoAllocMap).Free()
		x.ref53657584 = nil
	}
}

// NewCessPartitionSnarkProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPartitionSnarkProofRef(ref unsafe.Pointer) *CessPartitionSnarkProof {
	if ref == nil {
		return nil
	}
	obj := new(CessPartitionSnarkProof)
	obj.ref53657584 = (*C.cess_PartitionSnarkProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPartitionSnarkProof) PassRef() (*C.cess_PartitionSnarkProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref53657584 != nil {
		return x.ref53657584, nil
	}
	mem53657584 := allocCessPartitionSnarkProofMemory(1)
	ref53657584 := (*C.cess_PartitionSnarkProof)(mem53657584)
	allocs53657584 := new(cgoAllocMap)
	allocs53657584.Add(mem53657584)

	var cregistered_proof_allocs *cgoAllocMap
	ref53657584.registered_proof, cregistered_proof_allocs = (C.cess_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs53657584.Borrow(cregistered_proof_allocs)

	var cproof_len_allocs *cgoAllocMap
	ref53657584.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocs53657584.Borrow(cproof_len_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	ref53657584.proof_ptr, cproof_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.ProofPtr)))
	allocs53657584.Borrow(cproof_ptr_allocs)

	x.ref53657584 = ref53657584
	x.allocs53657584 = allocs53657584
	return ref53657584, allocs53657584

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPartitionSnarkProof) PassValue() (C.cess_PartitionSnarkProof, *cgoAllocMap) {
	if x.ref53657584 != nil {
		return *x.ref53657584, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPartitionSnarkProof) Deref() {
	if x.ref53657584 == nil {
		return
	}
	x.RegisteredProof = (CessRegisteredPoStProof)(x.ref53657584.registered_proof)
	x.ProofLen = (uint)(x.ref53657584.proof_len)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.ProofPtr))
	hxfa3f05c.Data = unsafe.Pointer(x.ref53657584.proof_ptr)
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

}

// allocCessGenerateSingleWindowPoStWithVanillaResponseMemory allocates memory for type C.cess_GenerateSingleWindowPoStWithVanillaResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateSingleWindowPoStWithVanillaResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateSingleWindowPoStWithVanillaResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateSingleWindowPoStWithVanillaResponseValue = unsafe.Sizeof([1]C.cess_GenerateSingleWindowPoStWithVanillaResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateSingleWindowPoStWithVanillaResponse) Ref() *C.cess_GenerateSingleWindowPoStWithVanillaResponse {
	if x == nil {
		return nil
	}
	return x.ref14f9c3a2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateSingleWindowPoStWithVanillaResponse) Free() {
	if x != nil && x.allocs14f9c3a2 != nil {
		x.allocs14f9c3a2.(*cgoAllocMap).Free()
		x.ref14f9c3a2 = nil
	}
}

// NewCessGenerateSingleWindowPoStWithVanillaResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateSingleWindowPoStWithVanillaResponseRef(ref unsafe.Pointer) *CessGenerateSingleWindowPoStWithVanillaResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateSingleWindowPoStWithVanillaResponse)
	obj.ref14f9c3a2 = (*C.cess_GenerateSingleWindowPoStWithVanillaResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateSingleWindowPoStWithVanillaResponse) PassRef() (*C.cess_GenerateSingleWindowPoStWithVanillaResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref14f9c3a2 != nil {
		return x.ref14f9c3a2, nil
	}
	mem14f9c3a2 := allocCessGenerateSingleWindowPoStWithVanillaResponseMemory(1)
	ref14f9c3a2 := (*C.cess_GenerateSingleWindowPoStWithVanillaResponse)(mem14f9c3a2)
	allocs14f9c3a2 := new(cgoAllocMap)
	allocs14f9c3a2.Add(mem14f9c3a2)

	var cerror_msg_allocs *cgoAllocMap
	ref14f9c3a2.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs14f9c3a2.Borrow(cerror_msg_allocs)

	var cpartition_proof_allocs *cgoAllocMap
	ref14f9c3a2.partition_proof, cpartition_proof_allocs = x.PartitionProof.PassValue()
	allocs14f9c3a2.Borrow(cpartition_proof_allocs)

	var cfaulty_sectors_len_allocs *cgoAllocMap
	ref14f9c3a2.faulty_sectors_len, cfaulty_sectors_len_allocs = (C.size_t)(x.FaultySectorsLen), cgoAllocsUnknown
	allocs14f9c3a2.Borrow(cfaulty_sectors_len_allocs)

	var cfaulty_sectors_ptr_allocs *cgoAllocMap
	ref14f9c3a2.faulty_sectors_ptr, cfaulty_sectors_ptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.FaultySectorsPtr)))
	allocs14f9c3a2.Borrow(cfaulty_sectors_ptr_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref14f9c3a2.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs14f9c3a2.Borrow(cstatus_code_allocs)

	x.ref14f9c3a2 = ref14f9c3a2
	x.allocs14f9c3a2 = allocs14f9c3a2
	return ref14f9c3a2, allocs14f9c3a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateSingleWindowPoStWithVanillaResponse) PassValue() (C.cess_GenerateSingleWindowPoStWithVanillaResponse, *cgoAllocMap) {
	if x.ref14f9c3a2 != nil {
		return *x.ref14f9c3a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateSingleWindowPoStWithVanillaResponse) Deref() {
	if x.ref14f9c3a2 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref14f9c3a2.error_msg)
	x.PartitionProof = *NewCessPartitionSnarkProofRef(unsafe.Pointer(&x.ref14f9c3a2.partition_proof))
	x.FaultySectorsLen = (uint)(x.ref14f9c3a2.faulty_sectors_len)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.FaultySectorsPtr))
	hxf0d18b7.Data = unsafe.Pointer(x.ref14f9c3a2.faulty_sectors_ptr)
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

	x.StatusCode = (FCPResponseStatus)(x.ref14f9c3a2.status_code)
}

// allocCessPoStProofMemory allocates memory for type C.cess_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPoStProofValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPoStProofValue = unsafe.Sizeof([1]C.cess_PoStProof{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPoStProof) Ref() *C.cess_PoStProof {
	if x == nil {
		return nil
	}
	return x.ref4bddd713
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPoStProof) Free() {
	if x != nil && x.allocs4bddd713 != nil {
		x.allocs4bddd713.(*cgoAllocMap).Free()
		x.ref4bddd713 = nil
	}
}

// NewCessPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPoStProofRef(ref unsafe.Pointer) *CessPoStProof {
	if ref == nil {
		return nil
	}
	obj := new(CessPoStProof)
	obj.ref4bddd713 = (*C.cess_PoStProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPoStProof) PassRef() (*C.cess_PoStProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4bddd713 != nil {
		return x.ref4bddd713, nil
	}
	mem4bddd713 := allocCessPoStProofMemory(1)
	ref4bddd713 := (*C.cess_PoStProof)(mem4bddd713)
	allocs4bddd713 := new(cgoAllocMap)
	allocs4bddd713.Add(mem4bddd713)

	var cregistered_proof_allocs *cgoAllocMap
	ref4bddd713.registered_proof, cregistered_proof_allocs = (C.cess_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs4bddd713.Borrow(cregistered_proof_allocs)

	var cproof_len_allocs *cgoAllocMap
	ref4bddd713.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocs4bddd713.Borrow(cproof_len_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	ref4bddd713.proof_ptr, cproof_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.ProofPtr)))
	allocs4bddd713.Borrow(cproof_ptr_allocs)

	x.ref4bddd713 = ref4bddd713
	x.allocs4bddd713 = allocs4bddd713
	return ref4bddd713, allocs4bddd713

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPoStProof) PassValue() (C.cess_PoStProof, *cgoAllocMap) {
	if x.ref4bddd713 != nil {
		return *x.ref4bddd713, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPoStProof) Deref() {
	if x.ref4bddd713 == nil {
		return
	}
	x.RegisteredProof = (CessRegisteredPoStProof)(x.ref4bddd713.registered_proof)
	x.ProofLen = (uint)(x.ref4bddd713.proof_len)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.ProofPtr))
	hxf2fab0d.Data = unsafe.Pointer(x.ref4bddd713.proof_ptr)
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

}

// allocCessGenerateWindowPoStResponseMemory allocates memory for type C.cess_GenerateWindowPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateWindowPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateWindowPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateWindowPoStResponseValue = unsafe.Sizeof([1]C.cess_GenerateWindowPoStResponse{})

// unpackSCessPoStProof transforms a sliced Go data structure into plain C format.
func unpackSCessPoStProof(x []CessPoStProof) (unpacked *C.cess_PoStProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessPoStProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_PoStProof)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_PoStProof)(h.Data)
	return
}

// packSCessPoStProof reads sliced Go data structure out from plain C format.
func packSCessPoStProof(v []CessPoStProof, ptr0 *C.cess_PoStProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessPoStProofValue]C.cess_PoStProof)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessPoStProofRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateWindowPoStResponse) Ref() *C.cess_GenerateWindowPoStResponse {
	if x == nil {
		return nil
	}
	return x.refe0ada1e1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateWindowPoStResponse) Free() {
	if x != nil && x.allocse0ada1e1 != nil {
		x.allocse0ada1e1.(*cgoAllocMap).Free()
		x.refe0ada1e1 = nil
	}
}

// NewCessGenerateWindowPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateWindowPoStResponseRef(ref unsafe.Pointer) *CessGenerateWindowPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateWindowPoStResponse)
	obj.refe0ada1e1 = (*C.cess_GenerateWindowPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateWindowPoStResponse) PassRef() (*C.cess_GenerateWindowPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe0ada1e1 != nil {
		return x.refe0ada1e1, nil
	}
	meme0ada1e1 := allocCessGenerateWindowPoStResponseMemory(1)
	refe0ada1e1 := (*C.cess_GenerateWindowPoStResponse)(meme0ada1e1)
	allocse0ada1e1 := new(cgoAllocMap)
	allocse0ada1e1.Add(meme0ada1e1)

	var cerror_msg_allocs *cgoAllocMap
	refe0ada1e1.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocse0ada1e1.Borrow(cerror_msg_allocs)

	var cproofs_len_allocs *cgoAllocMap
	refe0ada1e1.proofs_len, cproofs_len_allocs = (C.size_t)(x.ProofsLen), cgoAllocsUnknown
	allocse0ada1e1.Borrow(cproofs_len_allocs)

	var cproofs_ptr_allocs *cgoAllocMap
	refe0ada1e1.proofs_ptr, cproofs_ptr_allocs = unpackSCessPoStProof(x.ProofsPtr)
	allocse0ada1e1.Borrow(cproofs_ptr_allocs)

	var cfaulty_sectors_len_allocs *cgoAllocMap
	refe0ada1e1.faulty_sectors_len, cfaulty_sectors_len_allocs = (C.size_t)(x.FaultySectorsLen), cgoAllocsUnknown
	allocse0ada1e1.Borrow(cfaulty_sectors_len_allocs)

	var cfaulty_sectors_ptr_allocs *cgoAllocMap
	refe0ada1e1.faulty_sectors_ptr, cfaulty_sectors_ptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.FaultySectorsPtr)))
	allocse0ada1e1.Borrow(cfaulty_sectors_ptr_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refe0ada1e1.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocse0ada1e1.Borrow(cstatus_code_allocs)

	x.refe0ada1e1 = refe0ada1e1
	x.allocse0ada1e1 = allocse0ada1e1
	return refe0ada1e1, allocse0ada1e1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateWindowPoStResponse) PassValue() (C.cess_GenerateWindowPoStResponse, *cgoAllocMap) {
	if x.refe0ada1e1 != nil {
		return *x.refe0ada1e1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateWindowPoStResponse) Deref() {
	if x.refe0ada1e1 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.refe0ada1e1.error_msg)
	x.ProofsLen = (uint)(x.refe0ada1e1.proofs_len)
	packSCessPoStProof(x.ProofsPtr, x.refe0ada1e1.proofs_ptr)
	x.FaultySectorsLen = (uint)(x.refe0ada1e1.faulty_sectors_len)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.FaultySectorsPtr))
	hxf69fe70.Data = unsafe.Pointer(x.refe0ada1e1.faulty_sectors_ptr)
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.StatusCode = (FCPResponseStatus)(x.refe0ada1e1.status_code)
}

// allocCessGenerateWinningPoStResponseMemory allocates memory for type C.cess_GenerateWinningPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateWinningPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateWinningPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateWinningPoStResponseValue = unsafe.Sizeof([1]C.cess_GenerateWinningPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateWinningPoStResponse) Ref() *C.cess_GenerateWinningPoStResponse {
	if x == nil {
		return nil
	}
	return x.ref1bcfb342
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateWinningPoStResponse) Free() {
	if x != nil && x.allocs1bcfb342 != nil {
		x.allocs1bcfb342.(*cgoAllocMap).Free()
		x.ref1bcfb342 = nil
	}
}

// NewCessGenerateWinningPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateWinningPoStResponseRef(ref unsafe.Pointer) *CessGenerateWinningPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateWinningPoStResponse)
	obj.ref1bcfb342 = (*C.cess_GenerateWinningPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateWinningPoStResponse) PassRef() (*C.cess_GenerateWinningPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1bcfb342 != nil {
		return x.ref1bcfb342, nil
	}
	mem1bcfb342 := allocCessGenerateWinningPoStResponseMemory(1)
	ref1bcfb342 := (*C.cess_GenerateWinningPoStResponse)(mem1bcfb342)
	allocs1bcfb342 := new(cgoAllocMap)
	allocs1bcfb342.Add(mem1bcfb342)

	var cerror_msg_allocs *cgoAllocMap
	ref1bcfb342.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs1bcfb342.Borrow(cerror_msg_allocs)

	var cproofs_len_allocs *cgoAllocMap
	ref1bcfb342.proofs_len, cproofs_len_allocs = (C.size_t)(x.ProofsLen), cgoAllocsUnknown
	allocs1bcfb342.Borrow(cproofs_len_allocs)

	var cproofs_ptr_allocs *cgoAllocMap
	ref1bcfb342.proofs_ptr, cproofs_ptr_allocs = unpackSCessPoStProof(x.ProofsPtr)
	allocs1bcfb342.Borrow(cproofs_ptr_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref1bcfb342.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs1bcfb342.Borrow(cstatus_code_allocs)

	x.ref1bcfb342 = ref1bcfb342
	x.allocs1bcfb342 = allocs1bcfb342
	return ref1bcfb342, allocs1bcfb342

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateWinningPoStResponse) PassValue() (C.cess_GenerateWinningPoStResponse, *cgoAllocMap) {
	if x.ref1bcfb342 != nil {
		return *x.ref1bcfb342, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateWinningPoStResponse) Deref() {
	if x.ref1bcfb342 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref1bcfb342.error_msg)
	x.ProofsLen = (uint)(x.ref1bcfb342.proofs_len)
	packSCessPoStProof(x.ProofsPtr, x.ref1bcfb342.proofs_ptr)
	x.StatusCode = (FCPResponseStatus)(x.ref1bcfb342.status_code)
}

// allocCessGenerateWinningPoStSectorChallengeMemory allocates memory for type C.cess_GenerateWinningPoStSectorChallenge in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGenerateWinningPoStSectorChallengeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGenerateWinningPoStSectorChallengeValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGenerateWinningPoStSectorChallengeValue = unsafe.Sizeof([1]C.cess_GenerateWinningPoStSectorChallenge{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGenerateWinningPoStSectorChallenge) Ref() *C.cess_GenerateWinningPoStSectorChallenge {
	if x == nil {
		return nil
	}
	return x.refef471cd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGenerateWinningPoStSectorChallenge) Free() {
	if x != nil && x.allocsef471cd9 != nil {
		x.allocsef471cd9.(*cgoAllocMap).Free()
		x.refef471cd9 = nil
	}
}

// NewCessGenerateWinningPoStSectorChallengeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGenerateWinningPoStSectorChallengeRef(ref unsafe.Pointer) *CessGenerateWinningPoStSectorChallenge {
	if ref == nil {
		return nil
	}
	obj := new(CessGenerateWinningPoStSectorChallenge)
	obj.refef471cd9 = (*C.cess_GenerateWinningPoStSectorChallenge)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGenerateWinningPoStSectorChallenge) PassRef() (*C.cess_GenerateWinningPoStSectorChallenge, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refef471cd9 != nil {
		return x.refef471cd9, nil
	}
	memef471cd9 := allocCessGenerateWinningPoStSectorChallengeMemory(1)
	refef471cd9 := (*C.cess_GenerateWinningPoStSectorChallenge)(memef471cd9)
	allocsef471cd9 := new(cgoAllocMap)
	allocsef471cd9.Add(memef471cd9)

	var cerror_msg_allocs *cgoAllocMap
	refef471cd9.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsef471cd9.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refef471cd9.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsef471cd9.Borrow(cstatus_code_allocs)

	var cids_ptr_allocs *cgoAllocMap
	refef471cd9.ids_ptr, cids_ptr_allocs = copyPUint64TBytes((*sliceHeader)(unsafe.Pointer(&x.IdsPtr)))
	allocsef471cd9.Borrow(cids_ptr_allocs)

	var cids_len_allocs *cgoAllocMap
	refef471cd9.ids_len, cids_len_allocs = (C.size_t)(x.IdsLen), cgoAllocsUnknown
	allocsef471cd9.Borrow(cids_len_allocs)

	x.refef471cd9 = refef471cd9
	x.allocsef471cd9 = allocsef471cd9
	return refef471cd9, allocsef471cd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGenerateWinningPoStSectorChallenge) PassValue() (C.cess_GenerateWinningPoStSectorChallenge, *cgoAllocMap) {
	if x.refef471cd9 != nil {
		return *x.refef471cd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGenerateWinningPoStSectorChallenge) Deref() {
	if x.refef471cd9 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.refef471cd9.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.refef471cd9.status_code)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.IdsPtr))
	hxf65bf54.Data = unsafe.Pointer(x.refef471cd9.ids_ptr)
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

	x.IdsLen = (uint)(x.refef471cd9.ids_len)
}

// allocCessGetNumPartitionForFallbackPoStResponseMemory allocates memory for type C.cess_GetNumPartitionForFallbackPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGetNumPartitionForFallbackPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGetNumPartitionForFallbackPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGetNumPartitionForFallbackPoStResponseValue = unsafe.Sizeof([1]C.cess_GetNumPartitionForFallbackPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGetNumPartitionForFallbackPoStResponse) Ref() *C.cess_GetNumPartitionForFallbackPoStResponse {
	if x == nil {
		return nil
	}
	return x.ref6f2ab5bb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGetNumPartitionForFallbackPoStResponse) Free() {
	if x != nil && x.allocs6f2ab5bb != nil {
		x.allocs6f2ab5bb.(*cgoAllocMap).Free()
		x.ref6f2ab5bb = nil
	}
}

// NewCessGetNumPartitionForFallbackPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGetNumPartitionForFallbackPoStResponseRef(ref unsafe.Pointer) *CessGetNumPartitionForFallbackPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGetNumPartitionForFallbackPoStResponse)
	obj.ref6f2ab5bb = (*C.cess_GetNumPartitionForFallbackPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGetNumPartitionForFallbackPoStResponse) PassRef() (*C.cess_GetNumPartitionForFallbackPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6f2ab5bb != nil {
		return x.ref6f2ab5bb, nil
	}
	mem6f2ab5bb := allocCessGetNumPartitionForFallbackPoStResponseMemory(1)
	ref6f2ab5bb := (*C.cess_GetNumPartitionForFallbackPoStResponse)(mem6f2ab5bb)
	allocs6f2ab5bb := new(cgoAllocMap)
	allocs6f2ab5bb.Add(mem6f2ab5bb)

	var cerror_msg_allocs *cgoAllocMap
	ref6f2ab5bb.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs6f2ab5bb.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref6f2ab5bb.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs6f2ab5bb.Borrow(cstatus_code_allocs)

	var cnum_partition_allocs *cgoAllocMap
	ref6f2ab5bb.num_partition, cnum_partition_allocs = (C.size_t)(x.NumPartition), cgoAllocsUnknown
	allocs6f2ab5bb.Borrow(cnum_partition_allocs)

	x.ref6f2ab5bb = ref6f2ab5bb
	x.allocs6f2ab5bb = allocs6f2ab5bb
	return ref6f2ab5bb, allocs6f2ab5bb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGetNumPartitionForFallbackPoStResponse) PassValue() (C.cess_GetNumPartitionForFallbackPoStResponse, *cgoAllocMap) {
	if x.ref6f2ab5bb != nil {
		return *x.ref6f2ab5bb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGetNumPartitionForFallbackPoStResponse) Deref() {
	if x.ref6f2ab5bb == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref6f2ab5bb.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref6f2ab5bb.status_code)
	x.NumPartition = (uint)(x.ref6f2ab5bb.num_partition)
}

// allocCessGpuDeviceResponseMemory allocates memory for type C.cess_GpuDeviceResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessGpuDeviceResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessGpuDeviceResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessGpuDeviceResponseValue = unsafe.Sizeof([1]C.cess_GpuDeviceResponse{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessGpuDeviceResponse) Ref() *C.cess_GpuDeviceResponse {
	if x == nil {
		return nil
	}
	return x.ref566d6506
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessGpuDeviceResponse) Free() {
	if x != nil && x.allocs566d6506 != nil {
		x.allocs566d6506.(*cgoAllocMap).Free()
		x.ref566d6506 = nil
	}
}

// NewCessGpuDeviceResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessGpuDeviceResponseRef(ref unsafe.Pointer) *CessGpuDeviceResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessGpuDeviceResponse)
	obj.ref566d6506 = (*C.cess_GpuDeviceResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessGpuDeviceResponse) PassRef() (*C.cess_GpuDeviceResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref566d6506 != nil {
		return x.ref566d6506, nil
	}
	mem566d6506 := allocCessGpuDeviceResponseMemory(1)
	ref566d6506 := (*C.cess_GpuDeviceResponse)(mem566d6506)
	allocs566d6506 := new(cgoAllocMap)
	allocs566d6506.Add(mem566d6506)

	var cstatus_code_allocs *cgoAllocMap
	ref566d6506.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs566d6506.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref566d6506.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs566d6506.Borrow(cerror_msg_allocs)

	var cdevices_len_allocs *cgoAllocMap
	ref566d6506.devices_len, cdevices_len_allocs = (C.size_t)(x.DevicesLen), cgoAllocsUnknown
	allocs566d6506.Borrow(cdevices_len_allocs)

	var cdevices_ptr_allocs *cgoAllocMap
	ref566d6506.devices_ptr, cdevices_ptr_allocs = unpackSString(x.DevicesPtr)
	allocs566d6506.Borrow(cdevices_ptr_allocs)

	x.ref566d6506 = ref566d6506
	x.allocs566d6506 = allocs566d6506
	return ref566d6506, allocs566d6506

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessGpuDeviceResponse) PassValue() (C.cess_GpuDeviceResponse, *cgoAllocMap) {
	if x.ref566d6506 != nil {
		return *x.ref566d6506, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessGpuDeviceResponse) Deref() {
	if x.ref566d6506 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref566d6506.status_code)
	x.ErrorMsg = packPCharString(x.ref566d6506.error_msg)
	x.DevicesLen = (uint)(x.ref566d6506.devices_len)
	packSString(x.DevicesPtr, x.ref566d6506.devices_ptr)
}

// allocCessBLSDigestMemory allocates memory for type C.cess_BLSDigest in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessBLSDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessBLSDigestValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessBLSDigestValue = unsafe.Sizeof([1]C.cess_BLSDigest{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessBLSDigest) Ref() *C.cess_BLSDigest {
	if x == nil {
		return nil
	}
	return x.ref69c70b65
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessBLSDigest) Free() {
	if x != nil && x.allocs69c70b65 != nil {
		x.allocs69c70b65.(*cgoAllocMap).Free()
		x.ref69c70b65 = nil
	}
}

// NewCessBLSDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessBLSDigestRef(ref unsafe.Pointer) *CessBLSDigest {
	if ref == nil {
		return nil
	}
	obj := new(CessBLSDigest)
	obj.ref69c70b65 = (*C.cess_BLSDigest)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessBLSDigest) PassRef() (*C.cess_BLSDigest, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69c70b65 != nil {
		return x.ref69c70b65, nil
	}
	mem69c70b65 := allocCessBLSDigestMemory(1)
	ref69c70b65 := (*C.cess_BLSDigest)(mem69c70b65)
	allocs69c70b65 := new(cgoAllocMap)
	allocs69c70b65.Add(mem69c70b65)

	var cinner_allocs *cgoAllocMap
	ref69c70b65.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs69c70b65.Borrow(cinner_allocs)

	x.ref69c70b65 = ref69c70b65
	x.allocs69c70b65 = allocs69c70b65
	return ref69c70b65, allocs69c70b65

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessBLSDigest) PassValue() (C.cess_BLSDigest, *cgoAllocMap) {
	if x.ref69c70b65 != nil {
		return *x.ref69c70b65, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessBLSDigest) Deref() {
	if x.ref69c70b65 == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.ref69c70b65.inner))
}

// allocCessHashResponseMemory allocates memory for type C.cess_HashResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessHashResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessHashResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessHashResponseValue = unsafe.Sizeof([1]C.cess_HashResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessHashResponse) Ref() *C.cess_HashResponse {
	if x == nil {
		return nil
	}
	return x.reffa824abc
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessHashResponse) Free() {
	if x != nil && x.allocsfa824abc != nil {
		x.allocsfa824abc.(*cgoAllocMap).Free()
		x.reffa824abc = nil
	}
}

// NewCessHashResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessHashResponseRef(ref unsafe.Pointer) *CessHashResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessHashResponse)
	obj.reffa824abc = (*C.cess_HashResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessHashResponse) PassRef() (*C.cess_HashResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffa824abc != nil {
		return x.reffa824abc, nil
	}
	memfa824abc := allocCessHashResponseMemory(1)
	reffa824abc := (*C.cess_HashResponse)(memfa824abc)
	allocsfa824abc := new(cgoAllocMap)
	allocsfa824abc.Add(memfa824abc)

	var cdigest_allocs *cgoAllocMap
	reffa824abc.digest, cdigest_allocs = x.Digest.PassValue()
	allocsfa824abc.Borrow(cdigest_allocs)

	x.reffa824abc = reffa824abc
	x.allocsfa824abc = allocsfa824abc
	return reffa824abc, allocsfa824abc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessHashResponse) PassValue() (C.cess_HashResponse, *cgoAllocMap) {
	if x.reffa824abc != nil {
		return *x.reffa824abc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessHashResponse) Deref() {
	if x.reffa824abc == nil {
		return
	}
	x.Digest = *NewCessBLSDigestRef(unsafe.Pointer(&x.reffa824abc.digest))
}

// allocCessInitLogFdResponseMemory allocates memory for type C.cess_InitLogFdResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessInitLogFdResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessInitLogFdResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessInitLogFdResponseValue = unsafe.Sizeof([1]C.cess_InitLogFdResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessInitLogFdResponse) Ref() *C.cess_InitLogFdResponse {
	if x == nil {
		return nil
	}
	return x.ref328e461b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessInitLogFdResponse) Free() {
	if x != nil && x.allocs328e461b != nil {
		x.allocs328e461b.(*cgoAllocMap).Free()
		x.ref328e461b = nil
	}
}

// NewCessInitLogFdResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessInitLogFdResponseRef(ref unsafe.Pointer) *CessInitLogFdResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessInitLogFdResponse)
	obj.ref328e461b = (*C.cess_InitLogFdResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessInitLogFdResponse) PassRef() (*C.cess_InitLogFdResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref328e461b != nil {
		return x.ref328e461b, nil
	}
	mem328e461b := allocCessInitLogFdResponseMemory(1)
	ref328e461b := (*C.cess_InitLogFdResponse)(mem328e461b)
	allocs328e461b := new(cgoAllocMap)
	allocs328e461b.Add(mem328e461b)

	var cstatus_code_allocs *cgoAllocMap
	ref328e461b.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs328e461b.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref328e461b.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs328e461b.Borrow(cerror_msg_allocs)

	x.ref328e461b = ref328e461b
	x.allocs328e461b = allocs328e461b
	return ref328e461b, allocs328e461b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessInitLogFdResponse) PassValue() (C.cess_InitLogFdResponse, *cgoAllocMap) {
	if x.ref328e461b != nil {
		return *x.ref328e461b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessInitLogFdResponse) Deref() {
	if x.ref328e461b == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref328e461b.status_code)
	x.ErrorMsg = packPCharString(x.ref328e461b.error_msg)
}

// allocCessMergeWindowPoStPartitionProofsResponseMemory allocates memory for type C.cess_MergeWindowPoStPartitionProofsResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessMergeWindowPoStPartitionProofsResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessMergeWindowPoStPartitionProofsResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessMergeWindowPoStPartitionProofsResponseValue = unsafe.Sizeof([1]C.cess_MergeWindowPoStPartitionProofsResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessMergeWindowPoStPartitionProofsResponse) Ref() *C.cess_MergeWindowPoStPartitionProofsResponse {
	if x == nil {
		return nil
	}
	return x.ref9c4be48d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessMergeWindowPoStPartitionProofsResponse) Free() {
	if x != nil && x.allocs9c4be48d != nil {
		x.allocs9c4be48d.(*cgoAllocMap).Free()
		x.ref9c4be48d = nil
	}
}

// NewCessMergeWindowPoStPartitionProofsResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessMergeWindowPoStPartitionProofsResponseRef(ref unsafe.Pointer) *CessMergeWindowPoStPartitionProofsResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessMergeWindowPoStPartitionProofsResponse)
	obj.ref9c4be48d = (*C.cess_MergeWindowPoStPartitionProofsResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessMergeWindowPoStPartitionProofsResponse) PassRef() (*C.cess_MergeWindowPoStPartitionProofsResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9c4be48d != nil {
		return x.ref9c4be48d, nil
	}
	mem9c4be48d := allocCessMergeWindowPoStPartitionProofsResponseMemory(1)
	ref9c4be48d := (*C.cess_MergeWindowPoStPartitionProofsResponse)(mem9c4be48d)
	allocs9c4be48d := new(cgoAllocMap)
	allocs9c4be48d.Add(mem9c4be48d)

	var cerror_msg_allocs *cgoAllocMap
	ref9c4be48d.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs9c4be48d.Borrow(cerror_msg_allocs)

	var cproof_allocs *cgoAllocMap
	ref9c4be48d.proof, cproof_allocs = x.Proof.PassValue()
	allocs9c4be48d.Borrow(cproof_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref9c4be48d.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs9c4be48d.Borrow(cstatus_code_allocs)

	x.ref9c4be48d = ref9c4be48d
	x.allocs9c4be48d = allocs9c4be48d
	return ref9c4be48d, allocs9c4be48d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessMergeWindowPoStPartitionProofsResponse) PassValue() (C.cess_MergeWindowPoStPartitionProofsResponse, *cgoAllocMap) {
	if x.ref9c4be48d != nil {
		return *x.ref9c4be48d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessMergeWindowPoStPartitionProofsResponse) Deref() {
	if x.ref9c4be48d == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref9c4be48d.error_msg)
	x.Proof = *NewCessPoStProofRef(unsafe.Pointer(&x.ref9c4be48d.proof))
	x.StatusCode = (FCPResponseStatus)(x.ref9c4be48d.status_code)
}

// allocCessBLSPrivateKeyMemory allocates memory for type C.cess_BLSPrivateKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessBLSPrivateKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessBLSPrivateKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessBLSPrivateKeyValue = unsafe.Sizeof([1]C.cess_BLSPrivateKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessBLSPrivateKey) Ref() *C.cess_BLSPrivateKey {
	if x == nil {
		return nil
	}
	return x.refdd2a561c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessBLSPrivateKey) Free() {
	if x != nil && x.allocsdd2a561c != nil {
		x.allocsdd2a561c.(*cgoAllocMap).Free()
		x.refdd2a561c = nil
	}
}

// NewCessBLSPrivateKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessBLSPrivateKeyRef(ref unsafe.Pointer) *CessBLSPrivateKey {
	if ref == nil {
		return nil
	}
	obj := new(CessBLSPrivateKey)
	obj.refdd2a561c = (*C.cess_BLSPrivateKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessBLSPrivateKey) PassRef() (*C.cess_BLSPrivateKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdd2a561c != nil {
		return x.refdd2a561c, nil
	}
	memdd2a561c := allocCessBLSPrivateKeyMemory(1)
	refdd2a561c := (*C.cess_BLSPrivateKey)(memdd2a561c)
	allocsdd2a561c := new(cgoAllocMap)
	allocsdd2a561c.Add(memdd2a561c)

	var cinner_allocs *cgoAllocMap
	refdd2a561c.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocsdd2a561c.Borrow(cinner_allocs)

	x.refdd2a561c = refdd2a561c
	x.allocsdd2a561c = allocsdd2a561c
	return refdd2a561c, allocsdd2a561c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessBLSPrivateKey) PassValue() (C.cess_BLSPrivateKey, *cgoAllocMap) {
	if x.refdd2a561c != nil {
		return *x.refdd2a561c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessBLSPrivateKey) Deref() {
	if x.refdd2a561c == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.refdd2a561c.inner))
}

// allocCessPrivateKeyGenerateResponseMemory allocates memory for type C.cess_PrivateKeyGenerateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPrivateKeyGenerateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPrivateKeyGenerateResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPrivateKeyGenerateResponseValue = unsafe.Sizeof([1]C.cess_PrivateKeyGenerateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPrivateKeyGenerateResponse) Ref() *C.cess_PrivateKeyGenerateResponse {
	if x == nil {
		return nil
	}
	return x.refc8293ad6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPrivateKeyGenerateResponse) Free() {
	if x != nil && x.allocsc8293ad6 != nil {
		x.allocsc8293ad6.(*cgoAllocMap).Free()
		x.refc8293ad6 = nil
	}
}

// NewCessPrivateKeyGenerateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPrivateKeyGenerateResponseRef(ref unsafe.Pointer) *CessPrivateKeyGenerateResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessPrivateKeyGenerateResponse)
	obj.refc8293ad6 = (*C.cess_PrivateKeyGenerateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPrivateKeyGenerateResponse) PassRef() (*C.cess_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8293ad6 != nil {
		return x.refc8293ad6, nil
	}
	memc8293ad6 := allocCessPrivateKeyGenerateResponseMemory(1)
	refc8293ad6 := (*C.cess_PrivateKeyGenerateResponse)(memc8293ad6)
	allocsc8293ad6 := new(cgoAllocMap)
	allocsc8293ad6.Add(memc8293ad6)

	var cprivate_key_allocs *cgoAllocMap
	refc8293ad6.private_key, cprivate_key_allocs = x.PrivateKey.PassValue()
	allocsc8293ad6.Borrow(cprivate_key_allocs)

	x.refc8293ad6 = refc8293ad6
	x.allocsc8293ad6 = allocsc8293ad6
	return refc8293ad6, allocsc8293ad6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPrivateKeyGenerateResponse) PassValue() (C.cess_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x.refc8293ad6 != nil {
		return *x.refc8293ad6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPrivateKeyGenerateResponse) Deref() {
	if x.refc8293ad6 == nil {
		return
	}
	x.PrivateKey = *NewCessBLSPrivateKeyRef(unsafe.Pointer(&x.refc8293ad6.private_key))
}

// allocCessBLSPublicKeyMemory allocates memory for type C.cess_BLSPublicKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessBLSPublicKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessBLSPublicKeyValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessBLSPublicKeyValue = unsafe.Sizeof([1]C.cess_BLSPublicKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessBLSPublicKey) Ref() *C.cess_BLSPublicKey {
	if x == nil {
		return nil
	}
	return x.ref52a4c340
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessBLSPublicKey) Free() {
	if x != nil && x.allocs52a4c340 != nil {
		x.allocs52a4c340.(*cgoAllocMap).Free()
		x.ref52a4c340 = nil
	}
}

// NewCessBLSPublicKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessBLSPublicKeyRef(ref unsafe.Pointer) *CessBLSPublicKey {
	if ref == nil {
		return nil
	}
	obj := new(CessBLSPublicKey)
	obj.ref52a4c340 = (*C.cess_BLSPublicKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessBLSPublicKey) PassRef() (*C.cess_BLSPublicKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref52a4c340 != nil {
		return x.ref52a4c340, nil
	}
	mem52a4c340 := allocCessBLSPublicKeyMemory(1)
	ref52a4c340 := (*C.cess_BLSPublicKey)(mem52a4c340)
	allocs52a4c340 := new(cgoAllocMap)
	allocs52a4c340.Add(mem52a4c340)

	var cinner_allocs *cgoAllocMap
	ref52a4c340.inner, cinner_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs52a4c340.Borrow(cinner_allocs)

	x.ref52a4c340 = ref52a4c340
	x.allocs52a4c340 = allocs52a4c340
	return ref52a4c340, allocs52a4c340

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessBLSPublicKey) PassValue() (C.cess_BLSPublicKey, *cgoAllocMap) {
	if x.ref52a4c340 != nil {
		return *x.ref52a4c340, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessBLSPublicKey) Deref() {
	if x.ref52a4c340 == nil {
		return
	}
	x.Inner = *(*[48]byte)(unsafe.Pointer(&x.ref52a4c340.inner))
}

// allocCessPrivateKeyPublicKeyResponseMemory allocates memory for type C.cess_PrivateKeyPublicKeyResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPrivateKeyPublicKeyResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPrivateKeyPublicKeyResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPrivateKeyPublicKeyResponseValue = unsafe.Sizeof([1]C.cess_PrivateKeyPublicKeyResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPrivateKeyPublicKeyResponse) Ref() *C.cess_PrivateKeyPublicKeyResponse {
	if x == nil {
		return nil
	}
	return x.refe1deee33
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPrivateKeyPublicKeyResponse) Free() {
	if x != nil && x.allocse1deee33 != nil {
		x.allocse1deee33.(*cgoAllocMap).Free()
		x.refe1deee33 = nil
	}
}

// NewCessPrivateKeyPublicKeyResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPrivateKeyPublicKeyResponseRef(ref unsafe.Pointer) *CessPrivateKeyPublicKeyResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessPrivateKeyPublicKeyResponse)
	obj.refe1deee33 = (*C.cess_PrivateKeyPublicKeyResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPrivateKeyPublicKeyResponse) PassRef() (*C.cess_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe1deee33 != nil {
		return x.refe1deee33, nil
	}
	meme1deee33 := allocCessPrivateKeyPublicKeyResponseMemory(1)
	refe1deee33 := (*C.cess_PrivateKeyPublicKeyResponse)(meme1deee33)
	allocse1deee33 := new(cgoAllocMap)
	allocse1deee33.Add(meme1deee33)

	var cpublic_key_allocs *cgoAllocMap
	refe1deee33.public_key, cpublic_key_allocs = x.PublicKey.PassValue()
	allocse1deee33.Borrow(cpublic_key_allocs)

	x.refe1deee33 = refe1deee33
	x.allocse1deee33 = allocse1deee33
	return refe1deee33, allocse1deee33

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPrivateKeyPublicKeyResponse) PassValue() (C.cess_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x.refe1deee33 != nil {
		return *x.refe1deee33, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPrivateKeyPublicKeyResponse) Deref() {
	if x.refe1deee33 == nil {
		return
	}
	x.PublicKey = *NewCessBLSPublicKeyRef(unsafe.Pointer(&x.refe1deee33.public_key))
}

// allocCessPrivateKeySignResponseMemory allocates memory for type C.cess_PrivateKeySignResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPrivateKeySignResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPrivateKeySignResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPrivateKeySignResponseValue = unsafe.Sizeof([1]C.cess_PrivateKeySignResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPrivateKeySignResponse) Ref() *C.cess_PrivateKeySignResponse {
	if x == nil {
		return nil
	}
	return x.ref5fe24c5d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPrivateKeySignResponse) Free() {
	if x != nil && x.allocs5fe24c5d != nil {
		x.allocs5fe24c5d.(*cgoAllocMap).Free()
		x.ref5fe24c5d = nil
	}
}

// NewCessPrivateKeySignResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPrivateKeySignResponseRef(ref unsafe.Pointer) *CessPrivateKeySignResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessPrivateKeySignResponse)
	obj.ref5fe24c5d = (*C.cess_PrivateKeySignResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPrivateKeySignResponse) PassRef() (*C.cess_PrivateKeySignResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5fe24c5d != nil {
		return x.ref5fe24c5d, nil
	}
	mem5fe24c5d := allocCessPrivateKeySignResponseMemory(1)
	ref5fe24c5d := (*C.cess_PrivateKeySignResponse)(mem5fe24c5d)
	allocs5fe24c5d := new(cgoAllocMap)
	allocs5fe24c5d.Add(mem5fe24c5d)

	var csignature_allocs *cgoAllocMap
	ref5fe24c5d.signature, csignature_allocs = x.Signature.PassValue()
	allocs5fe24c5d.Borrow(csignature_allocs)

	x.ref5fe24c5d = ref5fe24c5d
	x.allocs5fe24c5d = allocs5fe24c5d
	return ref5fe24c5d, allocs5fe24c5d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPrivateKeySignResponse) PassValue() (C.cess_PrivateKeySignResponse, *cgoAllocMap) {
	if x.ref5fe24c5d != nil {
		return *x.ref5fe24c5d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPrivateKeySignResponse) Deref() {
	if x.ref5fe24c5d == nil {
		return
	}
	x.Signature = *NewCessBLSSignatureRef(unsafe.Pointer(&x.ref5fe24c5d.signature))
}

// allocCessSealCommitPhase1ResponseMemory allocates memory for type C.cess_SealCommitPhase1Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessSealCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessSealCommitPhase1ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessSealCommitPhase1ResponseValue = unsafe.Sizeof([1]C.cess_SealCommitPhase1Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessSealCommitPhase1Response) Ref() *C.cess_SealCommitPhase1Response {
	if x == nil {
		return nil
	}
	return x.ref8b183fc6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessSealCommitPhase1Response) Free() {
	if x != nil && x.allocs8b183fc6 != nil {
		x.allocs8b183fc6.(*cgoAllocMap).Free()
		x.ref8b183fc6 = nil
	}
}

// NewCessSealCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessSealCommitPhase1ResponseRef(ref unsafe.Pointer) *CessSealCommitPhase1Response {
	if ref == nil {
		return nil
	}
	obj := new(CessSealCommitPhase1Response)
	obj.ref8b183fc6 = (*C.cess_SealCommitPhase1Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessSealCommitPhase1Response) PassRef() (*C.cess_SealCommitPhase1Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8b183fc6 != nil {
		return x.ref8b183fc6, nil
	}
	mem8b183fc6 := allocCessSealCommitPhase1ResponseMemory(1)
	ref8b183fc6 := (*C.cess_SealCommitPhase1Response)(mem8b183fc6)
	allocs8b183fc6 := new(cgoAllocMap)
	allocs8b183fc6.Add(mem8b183fc6)

	var cstatus_code_allocs *cgoAllocMap
	ref8b183fc6.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs8b183fc6.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref8b183fc6.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs8b183fc6.Borrow(cerror_msg_allocs)

	var cseal_commit_phase1_output_ptr_allocs *cgoAllocMap
	ref8b183fc6.seal_commit_phase1_output_ptr, cseal_commit_phase1_output_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.SealCommitPhase1OutputPtr)))
	allocs8b183fc6.Borrow(cseal_commit_phase1_output_ptr_allocs)

	var cseal_commit_phase1_output_len_allocs *cgoAllocMap
	ref8b183fc6.seal_commit_phase1_output_len, cseal_commit_phase1_output_len_allocs = (C.size_t)(x.SealCommitPhase1OutputLen), cgoAllocsUnknown
	allocs8b183fc6.Borrow(cseal_commit_phase1_output_len_allocs)

	x.ref8b183fc6 = ref8b183fc6
	x.allocs8b183fc6 = allocs8b183fc6
	return ref8b183fc6, allocs8b183fc6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessSealCommitPhase1Response) PassValue() (C.cess_SealCommitPhase1Response, *cgoAllocMap) {
	if x.ref8b183fc6 != nil {
		return *x.ref8b183fc6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessSealCommitPhase1Response) Deref() {
	if x.ref8b183fc6 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref8b183fc6.status_code)
	x.ErrorMsg = packPCharString(x.ref8b183fc6.error_msg)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.SealCommitPhase1OutputPtr))
	hxf3b8dbd.Data = unsafe.Pointer(x.ref8b183fc6.seal_commit_phase1_output_ptr)
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

	x.SealCommitPhase1OutputLen = (uint)(x.ref8b183fc6.seal_commit_phase1_output_len)
}

// allocCessSealPreCommitPhase1ResponseMemory allocates memory for type C.cess_SealPreCommitPhase1Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessSealPreCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessSealPreCommitPhase1ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessSealPreCommitPhase1ResponseValue = unsafe.Sizeof([1]C.cess_SealPreCommitPhase1Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessSealPreCommitPhase1Response) Ref() *C.cess_SealPreCommitPhase1Response {
	if x == nil {
		return nil
	}
	return x.ref1ce1b476
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessSealPreCommitPhase1Response) Free() {
	if x != nil && x.allocs1ce1b476 != nil {
		x.allocs1ce1b476.(*cgoAllocMap).Free()
		x.ref1ce1b476 = nil
	}
}

// NewCessSealPreCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessSealPreCommitPhase1ResponseRef(ref unsafe.Pointer) *CessSealPreCommitPhase1Response {
	if ref == nil {
		return nil
	}
	obj := new(CessSealPreCommitPhase1Response)
	obj.ref1ce1b476 = (*C.cess_SealPreCommitPhase1Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessSealPreCommitPhase1Response) PassRef() (*C.cess_SealPreCommitPhase1Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1ce1b476 != nil {
		return x.ref1ce1b476, nil
	}
	mem1ce1b476 := allocCessSealPreCommitPhase1ResponseMemory(1)
	ref1ce1b476 := (*C.cess_SealPreCommitPhase1Response)(mem1ce1b476)
	allocs1ce1b476 := new(cgoAllocMap)
	allocs1ce1b476.Add(mem1ce1b476)

	var cerror_msg_allocs *cgoAllocMap
	ref1ce1b476.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs1ce1b476.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref1ce1b476.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs1ce1b476.Borrow(cstatus_code_allocs)

	var cseal_pre_commit_phase1_output_ptr_allocs *cgoAllocMap
	ref1ce1b476.seal_pre_commit_phase1_output_ptr, cseal_pre_commit_phase1_output_ptr_allocs = copyPUint8TBytes((*sliceHeader)(unsafe.Pointer(&x.SealPreCommitPhase1OutputPtr)))
	allocs1ce1b476.Borrow(cseal_pre_commit_phase1_output_ptr_allocs)

	var cseal_pre_commit_phase1_output_len_allocs *cgoAllocMap
	ref1ce1b476.seal_pre_commit_phase1_output_len, cseal_pre_commit_phase1_output_len_allocs = (C.size_t)(x.SealPreCommitPhase1OutputLen), cgoAllocsUnknown
	allocs1ce1b476.Borrow(cseal_pre_commit_phase1_output_len_allocs)

	x.ref1ce1b476 = ref1ce1b476
	x.allocs1ce1b476 = allocs1ce1b476
	return ref1ce1b476, allocs1ce1b476

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessSealPreCommitPhase1Response) PassValue() (C.cess_SealPreCommitPhase1Response, *cgoAllocMap) {
	if x.ref1ce1b476 != nil {
		return *x.ref1ce1b476, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessSealPreCommitPhase1Response) Deref() {
	if x.ref1ce1b476 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref1ce1b476.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref1ce1b476.status_code)
	hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&x.SealPreCommitPhase1OutputPtr))
	hxf7a6dff.Data = unsafe.Pointer(x.ref1ce1b476.seal_pre_commit_phase1_output_ptr)
	hxf7a6dff.Cap = 0x7fffffff
	// hxf7a6dff.Len = ?

	x.SealPreCommitPhase1OutputLen = (uint)(x.ref1ce1b476.seal_pre_commit_phase1_output_len)
}

// allocCessSealPreCommitPhase2ResponseMemory allocates memory for type C.cess_SealPreCommitPhase2Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessSealPreCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessSealPreCommitPhase2ResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessSealPreCommitPhase2ResponseValue = unsafe.Sizeof([1]C.cess_SealPreCommitPhase2Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessSealPreCommitPhase2Response) Ref() *C.cess_SealPreCommitPhase2Response {
	if x == nil {
		return nil
	}
	return x.ref256c88b3
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessSealPreCommitPhase2Response) Free() {
	if x != nil && x.allocs256c88b3 != nil {
		x.allocs256c88b3.(*cgoAllocMap).Free()
		x.ref256c88b3 = nil
	}
}

// NewCessSealPreCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessSealPreCommitPhase2ResponseRef(ref unsafe.Pointer) *CessSealPreCommitPhase2Response {
	if ref == nil {
		return nil
	}
	obj := new(CessSealPreCommitPhase2Response)
	obj.ref256c88b3 = (*C.cess_SealPreCommitPhase2Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessSealPreCommitPhase2Response) PassRef() (*C.cess_SealPreCommitPhase2Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref256c88b3 != nil {
		return x.ref256c88b3, nil
	}
	mem256c88b3 := allocCessSealPreCommitPhase2ResponseMemory(1)
	ref256c88b3 := (*C.cess_SealPreCommitPhase2Response)(mem256c88b3)
	allocs256c88b3 := new(cgoAllocMap)
	allocs256c88b3.Add(mem256c88b3)

	var cerror_msg_allocs *cgoAllocMap
	ref256c88b3.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs256c88b3.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref256c88b3.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs256c88b3.Borrow(cstatus_code_allocs)

	var cregistered_proof_allocs *cgoAllocMap
	ref256c88b3.registered_proof, cregistered_proof_allocs = (C.cess_RegisteredSealProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs256c88b3.Borrow(cregistered_proof_allocs)

	var ccomm_d_allocs *cgoAllocMap
	ref256c88b3.comm_d, ccomm_d_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommD)), cgoAllocsUnknown
	allocs256c88b3.Borrow(ccomm_d_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref256c88b3.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs256c88b3.Borrow(ccomm_r_allocs)

	x.ref256c88b3 = ref256c88b3
	x.allocs256c88b3 = allocs256c88b3
	return ref256c88b3, allocs256c88b3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessSealPreCommitPhase2Response) PassValue() (C.cess_SealPreCommitPhase2Response, *cgoAllocMap) {
	if x.ref256c88b3 != nil {
		return *x.ref256c88b3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessSealPreCommitPhase2Response) Deref() {
	if x.ref256c88b3 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref256c88b3.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref256c88b3.status_code)
	x.RegisteredProof = (CessRegisteredSealProof)(x.ref256c88b3.registered_proof)
	x.CommD = *(*[32]byte)(unsafe.Pointer(&x.ref256c88b3.comm_d))
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref256c88b3.comm_r))
}

// allocCessStringResponseMemory allocates memory for type C.cess_StringResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessStringResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessStringResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessStringResponseValue = unsafe.Sizeof([1]C.cess_StringResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessStringResponse) Ref() *C.cess_StringResponse {
	if x == nil {
		return nil
	}
	return x.ref9dbee816
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessStringResponse) Free() {
	if x != nil && x.allocs9dbee816 != nil {
		x.allocs9dbee816.(*cgoAllocMap).Free()
		x.ref9dbee816 = nil
	}
}

// NewCessStringResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessStringResponseRef(ref unsafe.Pointer) *CessStringResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessStringResponse)
	obj.ref9dbee816 = (*C.cess_StringResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessStringResponse) PassRef() (*C.cess_StringResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9dbee816 != nil {
		return x.ref9dbee816, nil
	}
	mem9dbee816 := allocCessStringResponseMemory(1)
	ref9dbee816 := (*C.cess_StringResponse)(mem9dbee816)
	allocs9dbee816 := new(cgoAllocMap)
	allocs9dbee816.Add(mem9dbee816)

	var cstatus_code_allocs *cgoAllocMap
	ref9dbee816.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs9dbee816.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref9dbee816.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs9dbee816.Borrow(cerror_msg_allocs)

	var cstring_val_allocs *cgoAllocMap
	ref9dbee816.string_val, cstring_val_allocs = unpackPCharString(x.StringVal)
	allocs9dbee816.Borrow(cstring_val_allocs)

	x.ref9dbee816 = ref9dbee816
	x.allocs9dbee816 = allocs9dbee816
	return ref9dbee816, allocs9dbee816

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessStringResponse) PassValue() (C.cess_StringResponse, *cgoAllocMap) {
	if x.ref9dbee816 != nil {
		return *x.ref9dbee816, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessStringResponse) Deref() {
	if x.ref9dbee816 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref9dbee816.status_code)
	x.ErrorMsg = packPCharString(x.ref9dbee816.error_msg)
	x.StringVal = packPCharString(x.ref9dbee816.string_val)
}

// allocCessUnsealRangeResponseMemory allocates memory for type C.cess_UnsealRangeResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessUnsealRangeResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessUnsealRangeResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessUnsealRangeResponseValue = unsafe.Sizeof([1]C.cess_UnsealRangeResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessUnsealRangeResponse) Ref() *C.cess_UnsealRangeResponse {
	if x == nil {
		return nil
	}
	return x.ref7f675b74
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessUnsealRangeResponse) Free() {
	if x != nil && x.allocs7f675b74 != nil {
		x.allocs7f675b74.(*cgoAllocMap).Free()
		x.ref7f675b74 = nil
	}
}

// NewCessUnsealRangeResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessUnsealRangeResponseRef(ref unsafe.Pointer) *CessUnsealRangeResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessUnsealRangeResponse)
	obj.ref7f675b74 = (*C.cess_UnsealRangeResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessUnsealRangeResponse) PassRef() (*C.cess_UnsealRangeResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7f675b74 != nil {
		return x.ref7f675b74, nil
	}
	mem7f675b74 := allocCessUnsealRangeResponseMemory(1)
	ref7f675b74 := (*C.cess_UnsealRangeResponse)(mem7f675b74)
	allocs7f675b74 := new(cgoAllocMap)
	allocs7f675b74.Add(mem7f675b74)

	var cstatus_code_allocs *cgoAllocMap
	ref7f675b74.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs7f675b74.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref7f675b74.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs7f675b74.Borrow(cerror_msg_allocs)

	x.ref7f675b74 = ref7f675b74
	x.allocs7f675b74 = allocs7f675b74
	return ref7f675b74, allocs7f675b74

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessUnsealRangeResponse) PassValue() (C.cess_UnsealRangeResponse, *cgoAllocMap) {
	if x.ref7f675b74 != nil {
		return *x.ref7f675b74, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessUnsealRangeResponse) Deref() {
	if x.ref7f675b74 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref7f675b74.status_code)
	x.ErrorMsg = packPCharString(x.ref7f675b74.error_msg)
}

// allocCessVerifyAggregateSealProofResponseMemory allocates memory for type C.cess_VerifyAggregateSealProofResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessVerifyAggregateSealProofResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessVerifyAggregateSealProofResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessVerifyAggregateSealProofResponseValue = unsafe.Sizeof([1]C.cess_VerifyAggregateSealProofResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessVerifyAggregateSealProofResponse) Ref() *C.cess_VerifyAggregateSealProofResponse {
	if x == nil {
		return nil
	}
	return x.ref5d7294f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessVerifyAggregateSealProofResponse) Free() {
	if x != nil && x.allocs5d7294f != nil {
		x.allocs5d7294f.(*cgoAllocMap).Free()
		x.ref5d7294f = nil
	}
}

// NewCessVerifyAggregateSealProofResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessVerifyAggregateSealProofResponseRef(ref unsafe.Pointer) *CessVerifyAggregateSealProofResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessVerifyAggregateSealProofResponse)
	obj.ref5d7294f = (*C.cess_VerifyAggregateSealProofResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessVerifyAggregateSealProofResponse) PassRef() (*C.cess_VerifyAggregateSealProofResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5d7294f != nil {
		return x.ref5d7294f, nil
	}
	mem5d7294f := allocCessVerifyAggregateSealProofResponseMemory(1)
	ref5d7294f := (*C.cess_VerifyAggregateSealProofResponse)(mem5d7294f)
	allocs5d7294f := new(cgoAllocMap)
	allocs5d7294f.Add(mem5d7294f)

	var cstatus_code_allocs *cgoAllocMap
	ref5d7294f.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5d7294f.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5d7294f.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs5d7294f.Borrow(cerror_msg_allocs)

	var cis_valid_allocs *cgoAllocMap
	ref5d7294f.is_valid, cis_valid_allocs = (C._Bool)(x.IsValid), cgoAllocsUnknown
	allocs5d7294f.Borrow(cis_valid_allocs)

	x.ref5d7294f = ref5d7294f
	x.allocs5d7294f = allocs5d7294f
	return ref5d7294f, allocs5d7294f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessVerifyAggregateSealProofResponse) PassValue() (C.cess_VerifyAggregateSealProofResponse, *cgoAllocMap) {
	if x.ref5d7294f != nil {
		return *x.ref5d7294f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessVerifyAggregateSealProofResponse) Deref() {
	if x.ref5d7294f == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref5d7294f.status_code)
	x.ErrorMsg = packPCharString(x.ref5d7294f.error_msg)
	x.IsValid = (bool)(x.ref5d7294f.is_valid)
}

// allocCessVerifySealResponseMemory allocates memory for type C.cess_VerifySealResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessVerifySealResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessVerifySealResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessVerifySealResponseValue = unsafe.Sizeof([1]C.cess_VerifySealResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessVerifySealResponse) Ref() *C.cess_VerifySealResponse {
	if x == nil {
		return nil
	}
	return x.ref5089a5eb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessVerifySealResponse) Free() {
	if x != nil && x.allocs5089a5eb != nil {
		x.allocs5089a5eb.(*cgoAllocMap).Free()
		x.ref5089a5eb = nil
	}
}

// NewCessVerifySealResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessVerifySealResponseRef(ref unsafe.Pointer) *CessVerifySealResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessVerifySealResponse)
	obj.ref5089a5eb = (*C.cess_VerifySealResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessVerifySealResponse) PassRef() (*C.cess_VerifySealResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5089a5eb != nil {
		return x.ref5089a5eb, nil
	}
	mem5089a5eb := allocCessVerifySealResponseMemory(1)
	ref5089a5eb := (*C.cess_VerifySealResponse)(mem5089a5eb)
	allocs5089a5eb := new(cgoAllocMap)
	allocs5089a5eb.Add(mem5089a5eb)

	var cstatus_code_allocs *cgoAllocMap
	ref5089a5eb.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5089a5eb.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5089a5eb.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs5089a5eb.Borrow(cerror_msg_allocs)

	var cis_valid_allocs *cgoAllocMap
	ref5089a5eb.is_valid, cis_valid_allocs = (C._Bool)(x.IsValid), cgoAllocsUnknown
	allocs5089a5eb.Borrow(cis_valid_allocs)

	x.ref5089a5eb = ref5089a5eb
	x.allocs5089a5eb = allocs5089a5eb
	return ref5089a5eb, allocs5089a5eb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessVerifySealResponse) PassValue() (C.cess_VerifySealResponse, *cgoAllocMap) {
	if x.ref5089a5eb != nil {
		return *x.ref5089a5eb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessVerifySealResponse) Deref() {
	if x.ref5089a5eb == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref5089a5eb.status_code)
	x.ErrorMsg = packPCharString(x.ref5089a5eb.error_msg)
	x.IsValid = (bool)(x.ref5089a5eb.is_valid)
}

// allocCessVerifyWindowPoStResponseMemory allocates memory for type C.cess_VerifyWindowPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessVerifyWindowPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessVerifyWindowPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessVerifyWindowPoStResponseValue = unsafe.Sizeof([1]C.cess_VerifyWindowPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessVerifyWindowPoStResponse) Ref() *C.cess_VerifyWindowPoStResponse {
	if x == nil {
		return nil
	}
	return x.refde316e38
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessVerifyWindowPoStResponse) Free() {
	if x != nil && x.allocsde316e38 != nil {
		x.allocsde316e38.(*cgoAllocMap).Free()
		x.refde316e38 = nil
	}
}

// NewCessVerifyWindowPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessVerifyWindowPoStResponseRef(ref unsafe.Pointer) *CessVerifyWindowPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessVerifyWindowPoStResponse)
	obj.refde316e38 = (*C.cess_VerifyWindowPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessVerifyWindowPoStResponse) PassRef() (*C.cess_VerifyWindowPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde316e38 != nil {
		return x.refde316e38, nil
	}
	memde316e38 := allocCessVerifyWindowPoStResponseMemory(1)
	refde316e38 := (*C.cess_VerifyWindowPoStResponse)(memde316e38)
	allocsde316e38 := new(cgoAllocMap)
	allocsde316e38.Add(memde316e38)

	var cstatus_code_allocs *cgoAllocMap
	refde316e38.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsde316e38.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refde316e38.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsde316e38.Borrow(cerror_msg_allocs)

	var cis_valid_allocs *cgoAllocMap
	refde316e38.is_valid, cis_valid_allocs = (C._Bool)(x.IsValid), cgoAllocsUnknown
	allocsde316e38.Borrow(cis_valid_allocs)

	x.refde316e38 = refde316e38
	x.allocsde316e38 = allocsde316e38
	return refde316e38, allocsde316e38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessVerifyWindowPoStResponse) PassValue() (C.cess_VerifyWindowPoStResponse, *cgoAllocMap) {
	if x.refde316e38 != nil {
		return *x.refde316e38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessVerifyWindowPoStResponse) Deref() {
	if x.refde316e38 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refde316e38.status_code)
	x.ErrorMsg = packPCharString(x.refde316e38.error_msg)
	x.IsValid = (bool)(x.refde316e38.is_valid)
}

// allocCessVerifyWinningPoStResponseMemory allocates memory for type C.cess_VerifyWinningPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessVerifyWinningPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessVerifyWinningPoStResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessVerifyWinningPoStResponseValue = unsafe.Sizeof([1]C.cess_VerifyWinningPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessVerifyWinningPoStResponse) Ref() *C.cess_VerifyWinningPoStResponse {
	if x == nil {
		return nil
	}
	return x.refe4fe45fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessVerifyWinningPoStResponse) Free() {
	if x != nil && x.allocse4fe45fd != nil {
		x.allocse4fe45fd.(*cgoAllocMap).Free()
		x.refe4fe45fd = nil
	}
}

// NewCessVerifyWinningPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessVerifyWinningPoStResponseRef(ref unsafe.Pointer) *CessVerifyWinningPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessVerifyWinningPoStResponse)
	obj.refe4fe45fd = (*C.cess_VerifyWinningPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessVerifyWinningPoStResponse) PassRef() (*C.cess_VerifyWinningPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe4fe45fd != nil {
		return x.refe4fe45fd, nil
	}
	meme4fe45fd := allocCessVerifyWinningPoStResponseMemory(1)
	refe4fe45fd := (*C.cess_VerifyWinningPoStResponse)(meme4fe45fd)
	allocse4fe45fd := new(cgoAllocMap)
	allocse4fe45fd.Add(meme4fe45fd)

	var cstatus_code_allocs *cgoAllocMap
	refe4fe45fd.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocse4fe45fd.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refe4fe45fd.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocse4fe45fd.Borrow(cerror_msg_allocs)

	var cis_valid_allocs *cgoAllocMap
	refe4fe45fd.is_valid, cis_valid_allocs = (C._Bool)(x.IsValid), cgoAllocsUnknown
	allocse4fe45fd.Borrow(cis_valid_allocs)

	x.refe4fe45fd = refe4fe45fd
	x.allocse4fe45fd = allocse4fe45fd
	return refe4fe45fd, allocse4fe45fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessVerifyWinningPoStResponse) PassValue() (C.cess_VerifyWinningPoStResponse, *cgoAllocMap) {
	if x.refe4fe45fd != nil {
		return *x.refe4fe45fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessVerifyWinningPoStResponse) Deref() {
	if x.refe4fe45fd == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refe4fe45fd.status_code)
	x.ErrorMsg = packPCharString(x.refe4fe45fd.error_msg)
	x.IsValid = (bool)(x.refe4fe45fd.is_valid)
}

// allocCessWriteWithAlignmentResponseMemory allocates memory for type C.cess_WriteWithAlignmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessWriteWithAlignmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessWriteWithAlignmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessWriteWithAlignmentResponseValue = unsafe.Sizeof([1]C.cess_WriteWithAlignmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessWriteWithAlignmentResponse) Ref() *C.cess_WriteWithAlignmentResponse {
	if x == nil {
		return nil
	}
	return x.refc0c19430
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessWriteWithAlignmentResponse) Free() {
	if x != nil && x.allocsc0c19430 != nil {
		x.allocsc0c19430.(*cgoAllocMap).Free()
		x.refc0c19430 = nil
	}
}

// NewCessWriteWithAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessWriteWithAlignmentResponseRef(ref unsafe.Pointer) *CessWriteWithAlignmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessWriteWithAlignmentResponse)
	obj.refc0c19430 = (*C.cess_WriteWithAlignmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessWriteWithAlignmentResponse) PassRef() (*C.cess_WriteWithAlignmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0c19430 != nil {
		return x.refc0c19430, nil
	}
	memc0c19430 := allocCessWriteWithAlignmentResponseMemory(1)
	refc0c19430 := (*C.cess_WriteWithAlignmentResponse)(memc0c19430)
	allocsc0c19430 := new(cgoAllocMap)
	allocsc0c19430.Add(memc0c19430)

	var ccomm_p_allocs *cgoAllocMap
	refc0c19430.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsc0c19430.Borrow(ccomm_p_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refc0c19430.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsc0c19430.Borrow(cerror_msg_allocs)

	var cleft_alignment_unpadded_allocs *cgoAllocMap
	refc0c19430.left_alignment_unpadded, cleft_alignment_unpadded_allocs = (C.uint64_t)(x.LeftAlignmentUnpadded), cgoAllocsUnknown
	allocsc0c19430.Borrow(cleft_alignment_unpadded_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refc0c19430.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsc0c19430.Borrow(cstatus_code_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	refc0c19430.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocsc0c19430.Borrow(ctotal_write_unpadded_allocs)

	x.refc0c19430 = refc0c19430
	x.allocsc0c19430 = allocsc0c19430
	return refc0c19430, allocsc0c19430

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessWriteWithAlignmentResponse) PassValue() (C.cess_WriteWithAlignmentResponse, *cgoAllocMap) {
	if x.refc0c19430 != nil {
		return *x.refc0c19430, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessWriteWithAlignmentResponse) Deref() {
	if x.refc0c19430 == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refc0c19430.comm_p))
	x.ErrorMsg = packPCharString(x.refc0c19430.error_msg)
	x.LeftAlignmentUnpadded = (uint64)(x.refc0c19430.left_alignment_unpadded)
	x.StatusCode = (FCPResponseStatus)(x.refc0c19430.status_code)
	x.TotalWriteUnpadded = (uint64)(x.refc0c19430.total_write_unpadded)
}

// allocCessWriteWithoutAlignmentResponseMemory allocates memory for type C.cess_WriteWithoutAlignmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessWriteWithoutAlignmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessWriteWithoutAlignmentResponseValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessWriteWithoutAlignmentResponseValue = unsafe.Sizeof([1]C.cess_WriteWithoutAlignmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessWriteWithoutAlignmentResponse) Ref() *C.cess_WriteWithoutAlignmentResponse {
	if x == nil {
		return nil
	}
	return x.refabd859fd
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessWriteWithoutAlignmentResponse) Free() {
	if x != nil && x.allocsabd859fd != nil {
		x.allocsabd859fd.(*cgoAllocMap).Free()
		x.refabd859fd = nil
	}
}

// NewCessWriteWithoutAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessWriteWithoutAlignmentResponseRef(ref unsafe.Pointer) *CessWriteWithoutAlignmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(CessWriteWithoutAlignmentResponse)
	obj.refabd859fd = (*C.cess_WriteWithoutAlignmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessWriteWithoutAlignmentResponse) PassRef() (*C.cess_WriteWithoutAlignmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refabd859fd != nil {
		return x.refabd859fd, nil
	}
	memabd859fd := allocCessWriteWithoutAlignmentResponseMemory(1)
	refabd859fd := (*C.cess_WriteWithoutAlignmentResponse)(memabd859fd)
	allocsabd859fd := new(cgoAllocMap)
	allocsabd859fd.Add(memabd859fd)

	var ccomm_p_allocs *cgoAllocMap
	refabd859fd.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsabd859fd.Borrow(ccomm_p_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refabd859fd.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsabd859fd.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refabd859fd.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsabd859fd.Borrow(cstatus_code_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	refabd859fd.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocsabd859fd.Borrow(ctotal_write_unpadded_allocs)

	x.refabd859fd = refabd859fd
	x.allocsabd859fd = allocsabd859fd
	return refabd859fd, allocsabd859fd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessWriteWithoutAlignmentResponse) PassValue() (C.cess_WriteWithoutAlignmentResponse, *cgoAllocMap) {
	if x.refabd859fd != nil {
		return *x.refabd859fd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessWriteWithoutAlignmentResponse) Deref() {
	if x.refabd859fd == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refabd859fd.comm_p))
	x.ErrorMsg = packPCharString(x.refabd859fd.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.refabd859fd.status_code)
	x.TotalWriteUnpadded = (uint64)(x.refabd859fd.total_write_unpadded)
}

// allocCessPublicPieceInfoMemory allocates memory for type C.cess_PublicPieceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPublicPieceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPublicPieceInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPublicPieceInfoValue = unsafe.Sizeof([1]C.cess_PublicPieceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPublicPieceInfo) Ref() *C.cess_PublicPieceInfo {
	if x == nil {
		return nil
	}
	return x.refcbd37f0f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPublicPieceInfo) Free() {
	if x != nil && x.allocscbd37f0f != nil {
		x.allocscbd37f0f.(*cgoAllocMap).Free()
		x.refcbd37f0f = nil
	}
}

// NewCessPublicPieceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPublicPieceInfoRef(ref unsafe.Pointer) *CessPublicPieceInfo {
	if ref == nil {
		return nil
	}
	obj := new(CessPublicPieceInfo)
	obj.refcbd37f0f = (*C.cess_PublicPieceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPublicPieceInfo) PassRef() (*C.cess_PublicPieceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcbd37f0f != nil {
		return x.refcbd37f0f, nil
	}
	memcbd37f0f := allocCessPublicPieceInfoMemory(1)
	refcbd37f0f := (*C.cess_PublicPieceInfo)(memcbd37f0f)
	allocscbd37f0f := new(cgoAllocMap)
	allocscbd37f0f.Add(memcbd37f0f)

	var cnum_bytes_allocs *cgoAllocMap
	refcbd37f0f.num_bytes, cnum_bytes_allocs = (C.uint64_t)(x.NumBytes), cgoAllocsUnknown
	allocscbd37f0f.Borrow(cnum_bytes_allocs)

	var ccomm_p_allocs *cgoAllocMap
	refcbd37f0f.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocscbd37f0f.Borrow(ccomm_p_allocs)

	x.refcbd37f0f = refcbd37f0f
	x.allocscbd37f0f = allocscbd37f0f
	return refcbd37f0f, allocscbd37f0f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPublicPieceInfo) PassValue() (C.cess_PublicPieceInfo, *cgoAllocMap) {
	if x.refcbd37f0f != nil {
		return *x.refcbd37f0f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPublicPieceInfo) Deref() {
	if x.refcbd37f0f == nil {
		return
	}
	x.NumBytes = (uint64)(x.refcbd37f0f.num_bytes)
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refcbd37f0f.comm_p))
}

// allocCessPrivateReplicaInfoMemory allocates memory for type C.cess_PrivateReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPrivateReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPrivateReplicaInfoValue = unsafe.Sizeof([1]C.cess_PrivateReplicaInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPrivateReplicaInfo) Ref() *C.cess_PrivateReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref513cb09
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPrivateReplicaInfo) Free() {
	if x != nil && x.allocs513cb09 != nil {
		x.allocs513cb09.(*cgoAllocMap).Free()
		x.ref513cb09 = nil
	}
}

// NewCessPrivateReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPrivateReplicaInfoRef(ref unsafe.Pointer) *CessPrivateReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(CessPrivateReplicaInfo)
	obj.ref513cb09 = (*C.cess_PrivateReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPrivateReplicaInfo) PassRef() (*C.cess_PrivateReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref513cb09 != nil {
		return x.ref513cb09, nil
	}
	mem513cb09 := allocCessPrivateReplicaInfoMemory(1)
	ref513cb09 := (*C.cess_PrivateReplicaInfo)(mem513cb09)
	allocs513cb09 := new(cgoAllocMap)
	allocs513cb09.Add(mem513cb09)

	var cregistered_proof_allocs *cgoAllocMap
	ref513cb09.registered_proof, cregistered_proof_allocs = (C.cess_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs513cb09.Borrow(cregistered_proof_allocs)

	var ccache_dir_path_allocs *cgoAllocMap
	ref513cb09.cache_dir_path, ccache_dir_path_allocs = unpackPCharString(x.CacheDirPath)
	allocs513cb09.Borrow(ccache_dir_path_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref513cb09.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs513cb09.Borrow(ccomm_r_allocs)

	var creplica_path_allocs *cgoAllocMap
	ref513cb09.replica_path, creplica_path_allocs = unpackPCharString(x.ReplicaPath)
	allocs513cb09.Borrow(creplica_path_allocs)

	var csector_id_allocs *cgoAllocMap
	ref513cb09.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs513cb09.Borrow(csector_id_allocs)

	x.ref513cb09 = ref513cb09
	x.allocs513cb09 = allocs513cb09
	return ref513cb09, allocs513cb09

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPrivateReplicaInfo) PassValue() (C.cess_PrivateReplicaInfo, *cgoAllocMap) {
	if x.ref513cb09 != nil {
		return *x.ref513cb09, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPrivateReplicaInfo) Deref() {
	if x.ref513cb09 == nil {
		return
	}
	x.RegisteredProof = (CessRegisteredPoStProof)(x.ref513cb09.registered_proof)
	x.CacheDirPath = packPCharString(x.ref513cb09.cache_dir_path)
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref513cb09.comm_r))
	x.ReplicaPath = packPCharString(x.ref513cb09.replica_path)
	x.SectorId = (uint64)(x.ref513cb09.sector_id)
}

// allocCessPublicReplicaInfoMemory allocates memory for type C.cess_PublicReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCessPublicReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCessPublicReplicaInfoValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfCessPublicReplicaInfoValue = unsafe.Sizeof([1]C.cess_PublicReplicaInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CessPublicReplicaInfo) Ref() *C.cess_PublicReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref8f225bd1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CessPublicReplicaInfo) Free() {
	if x != nil && x.allocs8f225bd1 != nil {
		x.allocs8f225bd1.(*cgoAllocMap).Free()
		x.ref8f225bd1 = nil
	}
}

// NewCessPublicReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCessPublicReplicaInfoRef(ref unsafe.Pointer) *CessPublicReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(CessPublicReplicaInfo)
	obj.ref8f225bd1 = (*C.cess_PublicReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CessPublicReplicaInfo) PassRef() (*C.cess_PublicReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8f225bd1 != nil {
		return x.ref8f225bd1, nil
	}
	mem8f225bd1 := allocCessPublicReplicaInfoMemory(1)
	ref8f225bd1 := (*C.cess_PublicReplicaInfo)(mem8f225bd1)
	allocs8f225bd1 := new(cgoAllocMap)
	allocs8f225bd1.Add(mem8f225bd1)

	var cregistered_proof_allocs *cgoAllocMap
	ref8f225bd1.registered_proof, cregistered_proof_allocs = (C.cess_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs8f225bd1.Borrow(cregistered_proof_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref8f225bd1.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs8f225bd1.Borrow(ccomm_r_allocs)

	var csector_id_allocs *cgoAllocMap
	ref8f225bd1.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs8f225bd1.Borrow(csector_id_allocs)

	x.ref8f225bd1 = ref8f225bd1
	x.allocs8f225bd1 = allocs8f225bd1
	return ref8f225bd1, allocs8f225bd1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CessPublicReplicaInfo) PassValue() (C.cess_PublicReplicaInfo, *cgoAllocMap) {
	if x.ref8f225bd1 != nil {
		return *x.ref8f225bd1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CessPublicReplicaInfo) Deref() {
	if x.ref8f225bd1 == nil {
		return
	}
	x.RegisteredProof = (CessRegisteredPoStProof)(x.ref8f225bd1.registered_proof)
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref8f225bd1.comm_r))
	x.SectorId = (uint64)(x.ref8f225bd1.sector_id)
}

// unpackArgSCess32ByteArray transforms a sliced Go data structure into plain C format.
func unpackArgSCess32ByteArray(x []Cess32ByteArray) (unpacked *C.cess_32ByteArray, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCess32ByteArrayMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_32ByteArray)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_32ByteArray)(h.Data)
	return
}

// packSCess32ByteArray reads sliced Go data structure out from plain C format.
func packSCess32ByteArray(v []Cess32ByteArray, ptr0 *C.cess_32ByteArray) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCess32ByteArrayValue]C.cess_32ByteArray)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCess32ByteArrayRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCessSealCommitPhase2Response transforms a sliced Go data structure into plain C format.
func unpackArgSCessSealCommitPhase2Response(x []CessSealCommitPhase2Response) (unpacked *C.cess_SealCommitPhase2Response, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessSealCommitPhase2ResponseMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_SealCommitPhase2Response)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_SealCommitPhase2Response)(h.Data)
	return
}

// packSCessSealCommitPhase2Response reads sliced Go data structure out from plain C format.
func packSCessSealCommitPhase2Response(v []CessSealCommitPhase2Response, ptr0 *C.cess_SealCommitPhase2Response) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessSealCommitPhase2ResponseValue]C.cess_SealCommitPhase2Response)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessSealCommitPhase2ResponseRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCessPublicPieceInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCessPublicPieceInfo(x []CessPublicPieceInfo) (unpacked *C.cess_PublicPieceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessPublicPieceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_PublicPieceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_PublicPieceInfo)(h.Data)
	return
}

// packSCessPublicPieceInfo reads sliced Go data structure out from plain C format.
func packSCessPublicPieceInfo(v []CessPublicPieceInfo, ptr0 *C.cess_PublicPieceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessPublicPieceInfoValue]C.cess_PublicPieceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessPublicPieceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCessVanillaProof transforms a sliced Go data structure into plain C format.
func unpackArgSCessVanillaProof(x []CessVanillaProof) (unpacked *C.cess_VanillaProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessVanillaProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_VanillaProof)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_VanillaProof)(h.Data)
	return
}

// packSCessVanillaProof reads sliced Go data structure out from plain C format.
func packSCessVanillaProof(v []CessVanillaProof, ptr0 *C.cess_VanillaProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessVanillaProofValue]C.cess_VanillaProof)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessVanillaProofRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCessPrivateReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCessPrivateReplicaInfo(x []CessPrivateReplicaInfo) (unpacked *C.cess_PrivateReplicaInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessPrivateReplicaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_PrivateReplicaInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_PrivateReplicaInfo)(h.Data)
	return
}

// packSCessPrivateReplicaInfo reads sliced Go data structure out from plain C format.
func packSCessPrivateReplicaInfo(v []CessPrivateReplicaInfo, ptr0 *C.cess_PrivateReplicaInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessPrivateReplicaInfoValue]C.cess_PrivateReplicaInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessPrivateReplicaInfoRef(unsafe.Pointer(&ptr1))
	}
}

// copyPSizeTBytes copies the data from Go slice as *C.size_t.
func copyPSizeTBytes(slice *sliceHeader) (*C.size_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfSizeTValue) * slice.Len,
		Cap:  int(sizeOfSizeTValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.size_t)(mem0), allocs
}

// allocSizeTMemory allocates memory for type C.size_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSizeTMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSizeTValue))
	if mem == nil {
		panic(fmt.Sprintln("memory alloc error: ", err))
	}
	return mem
}

const sizeOfSizeTValue = unsafe.Sizeof([1]C.size_t{})

// unpackArgSCessPartitionSnarkProof transforms a sliced Go data structure into plain C format.
func unpackArgSCessPartitionSnarkProof(x []CessPartitionSnarkProof) (unpacked *C.cess_PartitionSnarkProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessPartitionSnarkProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_PartitionSnarkProof)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_PartitionSnarkProof)(h.Data)
	return
}

// packSCessPartitionSnarkProof reads sliced Go data structure out from plain C format.
func packSCessPartitionSnarkProof(v []CessPartitionSnarkProof, ptr0 *C.cess_PartitionSnarkProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessPartitionSnarkProofValue]C.cess_PartitionSnarkProof)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessPartitionSnarkProofRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCessAggregationInputs transforms a sliced Go data structure into plain C format.
func unpackArgSCessAggregationInputs(x []CessAggregationInputs) (unpacked *C.cess_AggregationInputs, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessAggregationInputsMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_AggregationInputs)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_AggregationInputs)(h.Data)
	return
}

// unpackArgSCessPublicReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSCessPublicReplicaInfo(x []CessPublicReplicaInfo) (unpacked *C.cess_PublicReplicaInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessPublicReplicaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_PublicReplicaInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_PublicReplicaInfo)(h.Data)
	return
}

// packSCessPublicReplicaInfo reads sliced Go data structure out from plain C format.
func packSCessPublicReplicaInfo(v []CessPublicReplicaInfo, ptr0 *C.cess_PublicReplicaInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfCessPublicReplicaInfoValue]C.cess_PublicReplicaInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewCessPublicReplicaInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSCessPoStProof transforms a sliced Go data structure into plain C format.
func unpackArgSCessPoStProof(x []CessPoStProof) (unpacked *C.cess_PoStProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	len0 := len(x)
	mem0 := allocCessPoStProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.cess_PoStProof)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.cess_PoStProof)(h.Data)
	return
}
